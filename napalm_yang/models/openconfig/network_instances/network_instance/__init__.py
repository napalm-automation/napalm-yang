
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import fdb
import config
import state
import encapsulation
import inter_instance_policies
import table_connections
import interfaces
import tables
import connection_points
import mpls
import segment_routing
import vlans
import policy_forwarding
import afts
import protocols
class network_instance(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance - based on the path /network-instances/network-instance. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Network instances configured on the local system
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__name','__fdb','__config','__state','__encapsulation','__inter_instance_policies','__table_connections','__interfaces','__tables','__connection_points','__mpls','__segment_routing','__vlans','__policy_forwarding','__afts','__protocols',)

  _yang_name = 'network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__tables = YANGDynClass(base=tables.tables, is_container='container', yang_name="tables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__fdb = YANGDynClass(base=fdb.fdb, is_container='container', yang_name="fdb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    self.__afts = YANGDynClass(base=afts.afts, is_container='container', yang_name="afts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__interfaces = YANGDynClass(base=interfaces.interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__mpls = YANGDynClass(base=mpls.mpls, is_container='container', yang_name="mpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__table_connections = YANGDynClass(base=table_connections.table_connections, is_container='container', yang_name="table-connections", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__connection_points = YANGDynClass(base=connection_points.connection_points, is_container='container', yang_name="connection-points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__inter_instance_policies = YANGDynClass(base=inter_instance_policies.inter_instance_policies, is_container='container', yang_name="inter-instance-policies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__encapsulation = YANGDynClass(base=encapsulation.encapsulation, is_container='container', yang_name="encapsulation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__segment_routing = YANGDynClass(base=segment_routing.segment_routing, is_container='container', yang_name="segment-routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__vlans = YANGDynClass(base=vlans.vlans, is_container='container', yang_name="vlans", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__protocols = YANGDynClass(base=protocols.protocols, is_container='container', yang_name="protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__policy_forwarding = YANGDynClass(base=policy_forwarding.policy_forwarding, is_container='container', yang_name="policy-forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'network-instances', u'network-instance']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /network_instances/network_instance/name (leafref)

    YANG Description: A unique name identifying the network instance
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /network_instances/network_instance/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: A unique name identifying the network instance
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)


  def _get_fdb(self):
    """
    Getter method for fdb, mapped from YANG variable /network_instances/network_instance/fdb (container)

    YANG Description: Operational state and configuration parameters relating to
the forwarding database of the network instance
    """
    return self.__fdb
      
  def _set_fdb(self, v, load=False):
    """
    Setter method for fdb, mapped from YANG variable /network_instances/network_instance/fdb (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fdb is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fdb() directly.

    YANG Description: Operational state and configuration parameters relating to
the forwarding database of the network instance
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=fdb.fdb, is_container='container', yang_name="fdb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fdb must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=fdb.fdb, is_container='container', yang_name="fdb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__fdb = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fdb(self):
    self.__fdb = YANGDynClass(base=fdb.fdb, is_container='container', yang_name="fdb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /network_instances/network_instance/config (container)

    YANG Description: Configuration parameters relating to a network
instance
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /network_instances/network_instance/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration parameters relating to a network
instance
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /network_instances/network_instance/state (container)

    YANG Description: Operational state parameters relating to a network
instance
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /network_instances/network_instance/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state parameters relating to a network
instance
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_encapsulation(self):
    """
    Getter method for encapsulation, mapped from YANG variable /network_instances/network_instance/encapsulation (container)

    YANG Description: Configuration parameters relating to the encapsulation
used for the network instance
    """
    return self.__encapsulation
      
  def _set_encapsulation(self, v, load=False):
    """
    Setter method for encapsulation, mapped from YANG variable /network_instances/network_instance/encapsulation (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_encapsulation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_encapsulation() directly.

    YANG Description: Configuration parameters relating to the encapsulation
used for the network instance
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=encapsulation.encapsulation, is_container='container', yang_name="encapsulation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """encapsulation must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=encapsulation.encapsulation, is_container='container', yang_name="encapsulation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__encapsulation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_encapsulation(self):
    self.__encapsulation = YANGDynClass(base=encapsulation.encapsulation, is_container='container', yang_name="encapsulation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_inter_instance_policies(self):
    """
    Getter method for inter_instance_policies, mapped from YANG variable /network_instances/network_instance/inter_instance_policies (container)

    YANG Description: Policies dictating how RIB or FIB entries are imported
to and exported from this instance
    """
    return self.__inter_instance_policies
      
  def _set_inter_instance_policies(self, v, load=False):
    """
    Setter method for inter_instance_policies, mapped from YANG variable /network_instances/network_instance/inter_instance_policies (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inter_instance_policies is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inter_instance_policies() directly.

    YANG Description: Policies dictating how RIB or FIB entries are imported
to and exported from this instance
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=inter_instance_policies.inter_instance_policies, is_container='container', yang_name="inter-instance-policies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inter_instance_policies must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=inter_instance_policies.inter_instance_policies, is_container='container', yang_name="inter-instance-policies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__inter_instance_policies = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inter_instance_policies(self):
    self.__inter_instance_policies = YANGDynClass(base=inter_instance_policies.inter_instance_policies, is_container='container', yang_name="inter-instance-policies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_table_connections(self):
    """
    Getter method for table_connections, mapped from YANG variable /network_instances/network_instance/table_connections (container)

    YANG Description: Policies dictating how RIB or FIB entries are propagated
between tables
    """
    return self.__table_connections
      
  def _set_table_connections(self, v, load=False):
    """
    Setter method for table_connections, mapped from YANG variable /network_instances/network_instance/table_connections (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_table_connections is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_table_connections() directly.

    YANG Description: Policies dictating how RIB or FIB entries are propagated
between tables
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=table_connections.table_connections, is_container='container', yang_name="table-connections", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """table_connections must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=table_connections.table_connections, is_container='container', yang_name="table-connections", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__table_connections = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_table_connections(self):
    self.__table_connections = YANGDynClass(base=table_connections.table_connections, is_container='container', yang_name="table-connections", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_interfaces(self):
    """
    Getter method for interfaces, mapped from YANG variable /network_instances/network_instance/interfaces (container)

    YANG Description: The interfaces that are associated with this network
instance
    """
    return self.__interfaces
      
  def _set_interfaces(self, v, load=False):
    """
    Setter method for interfaces, mapped from YANG variable /network_instances/network_instance/interfaces (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interfaces() directly.

    YANG Description: The interfaces that are associated with this network
instance
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=interfaces.interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interfaces must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=interfaces.interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__interfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interfaces(self):
    self.__interfaces = YANGDynClass(base=interfaces.interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_tables(self):
    """
    Getter method for tables, mapped from YANG variable /network_instances/network_instance/tables (container)

    YANG Description: The routing tables that are managed by this network
instance
    """
    return self.__tables
      
  def _set_tables(self, v, load=False):
    """
    Setter method for tables, mapped from YANG variable /network_instances/network_instance/tables (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tables is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tables() directly.

    YANG Description: The routing tables that are managed by this network
instance
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=tables.tables, is_container='container', yang_name="tables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tables must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=tables.tables, is_container='container', yang_name="tables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__tables = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tables(self):
    self.__tables = YANGDynClass(base=tables.tables, is_container='container', yang_name="tables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_connection_points(self):
    """
    Getter method for connection_points, mapped from YANG variable /network_instances/network_instance/connection_points (container)

    YANG Description: The set of connection points within a forwarding
instance
    """
    return self.__connection_points
      
  def _set_connection_points(self, v, load=False):
    """
    Setter method for connection_points, mapped from YANG variable /network_instances/network_instance/connection_points (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connection_points is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connection_points() directly.

    YANG Description: The set of connection points within a forwarding
instance
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=connection_points.connection_points, is_container='container', yang_name="connection-points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connection_points must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=connection_points.connection_points, is_container='container', yang_name="connection-points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__connection_points = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connection_points(self):
    self.__connection_points = YANGDynClass(base=connection_points.connection_points, is_container='container', yang_name="connection-points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_mpls(self):
    """
    Getter method for mpls, mapped from YANG variable /network_instances/network_instance/mpls (container)

    YANG Description: Anchor point for mpls configuration and operational
data
    """
    return self.__mpls
      
  def _set_mpls(self, v, load=False):
    """
    Setter method for mpls, mapped from YANG variable /network_instances/network_instance/mpls (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mpls is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mpls() directly.

    YANG Description: Anchor point for mpls configuration and operational
data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=mpls.mpls, is_container='container', yang_name="mpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mpls must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=mpls.mpls, is_container='container', yang_name="mpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__mpls = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mpls(self):
    self.__mpls = YANGDynClass(base=mpls.mpls, is_container='container', yang_name="mpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_segment_routing(self):
    """
    Getter method for segment_routing, mapped from YANG variable /network_instances/network_instance/segment_routing (container)

    YANG Description: Configuration and operational state parameters relating to
segment routing.
    """
    return self.__segment_routing
      
  def _set_segment_routing(self, v, load=False):
    """
    Setter method for segment_routing, mapped from YANG variable /network_instances/network_instance/segment_routing (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_segment_routing is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_segment_routing() directly.

    YANG Description: Configuration and operational state parameters relating to
segment routing.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=segment_routing.segment_routing, is_container='container', yang_name="segment-routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """segment_routing must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=segment_routing.segment_routing, is_container='container', yang_name="segment-routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__segment_routing = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_segment_routing(self):
    self.__segment_routing = YANGDynClass(base=segment_routing.segment_routing, is_container='container', yang_name="segment-routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_vlans(self):
    """
    Getter method for vlans, mapped from YANG variable /network_instances/network_instance/vlans (container)

    YANG Description: Container for VLAN configuration and state
variables
    """
    return self.__vlans
      
  def _set_vlans(self, v, load=False):
    """
    Setter method for vlans, mapped from YANG variable /network_instances/network_instance/vlans (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlans is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlans() directly.

    YANG Description: Container for VLAN configuration and state
variables
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=vlans.vlans, is_container='container', yang_name="vlans", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlans must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=vlans.vlans, is_container='container', yang_name="vlans", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__vlans = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlans(self):
    self.__vlans = YANGDynClass(base=vlans.vlans, is_container='container', yang_name="vlans", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_policy_forwarding(self):
    """
    Getter method for policy_forwarding, mapped from YANG variable /network_instances/network_instance/policy_forwarding (container)

    YANG Description: Configuration and operational state relating to policy-forwarding within
a network instance.
    """
    return self.__policy_forwarding
      
  def _set_policy_forwarding(self, v, load=False):
    """
    Setter method for policy_forwarding, mapped from YANG variable /network_instances/network_instance/policy_forwarding (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy_forwarding is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy_forwarding() directly.

    YANG Description: Configuration and operational state relating to policy-forwarding within
a network instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=policy_forwarding.policy_forwarding, is_container='container', yang_name="policy-forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policy_forwarding must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=policy_forwarding.policy_forwarding, is_container='container', yang_name="policy-forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__policy_forwarding = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policy_forwarding(self):
    self.__policy_forwarding = YANGDynClass(base=policy_forwarding.policy_forwarding, is_container='container', yang_name="policy-forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_afts(self):
    """
    Getter method for afts, mapped from YANG variable /network_instances/network_instance/afts (container)

    YANG Description: The abstract forwarding tables (AFTs) that are associated
with the network instance. An AFT is instantiated per-protocol
running within the network-instance - such that one exists for
IPv4 Unicast, IPv6 Unicast, MPLS, L2 forwarding entries, etc.
A forwarding entry within the FIB has a set of next-hops,
which may be a reference to an entry within another table -
e.g., where a Layer 3 next-hop has an associated Layer 2
forwarding entry.
    """
    return self.__afts
      
  def _set_afts(self, v, load=False):
    """
    Setter method for afts, mapped from YANG variable /network_instances/network_instance/afts (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_afts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_afts() directly.

    YANG Description: The abstract forwarding tables (AFTs) that are associated
with the network instance. An AFT is instantiated per-protocol
running within the network-instance - such that one exists for
IPv4 Unicast, IPv6 Unicast, MPLS, L2 forwarding entries, etc.
A forwarding entry within the FIB has a set of next-hops,
which may be a reference to an entry within another table -
e.g., where a Layer 3 next-hop has an associated Layer 2
forwarding entry.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=afts.afts, is_container='container', yang_name="afts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """afts must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=afts.afts, is_container='container', yang_name="afts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__afts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_afts(self):
    self.__afts = YANGDynClass(base=afts.afts, is_container='container', yang_name="afts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_protocols(self):
    """
    Getter method for protocols, mapped from YANG variable /network_instances/network_instance/protocols (container)

    YANG Description: The routing protocols that are enabled for this
network-instance.
    """
    return self.__protocols
      
  def _set_protocols(self, v, load=False):
    """
    Setter method for protocols, mapped from YANG variable /network_instances/network_instance/protocols (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocols is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocols() directly.

    YANG Description: The routing protocols that are enabled for this
network-instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=protocols.protocols, is_container='container', yang_name="protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocols must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=protocols.protocols, is_container='container', yang_name="protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__protocols = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocols(self):
    self.__protocols = YANGDynClass(base=protocols.protocols, is_container='container', yang_name="protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  fdb = __builtin__.property(_get_fdb, _set_fdb)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  encapsulation = __builtin__.property(_get_encapsulation, _set_encapsulation)
  inter_instance_policies = __builtin__.property(_get_inter_instance_policies, _set_inter_instance_policies)
  table_connections = __builtin__.property(_get_table_connections, _set_table_connections)
  interfaces = __builtin__.property(_get_interfaces, _set_interfaces)
  tables = __builtin__.property(_get_tables, _set_tables)
  connection_points = __builtin__.property(_get_connection_points, _set_connection_points)
  mpls = __builtin__.property(_get_mpls, _set_mpls)
  segment_routing = __builtin__.property(_get_segment_routing, _set_segment_routing)
  vlans = __builtin__.property(_get_vlans, _set_vlans)
  policy_forwarding = __builtin__.property(_get_policy_forwarding, _set_policy_forwarding)
  afts = __builtin__.property(_get_afts, _set_afts)
  protocols = __builtin__.property(_get_protocols, _set_protocols)


  _pyangbind_elements = {'name': name, 'fdb': fdb, 'config': config, 'state': state, 'encapsulation': encapsulation, 'inter_instance_policies': inter_instance_policies, 'table_connections': table_connections, 'interfaces': interfaces, 'tables': tables, 'connection_points': connection_points, 'mpls': mpls, 'segment_routing': segment_routing, 'vlans': vlans, 'policy_forwarding': policy_forwarding, 'afts': afts, 'protocols': protocols, }


import fdb
import config
import state
import encapsulation
import inter_instance_policies
import table_connections
import interfaces
import tables
import connection_points
import mpls
import segment_routing
import vlans
import policy_forwarding
import afts
import protocols
class network_instance(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance-l2 - based on the path /network-instances/network-instance. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Network instances configured on the local system
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__name','__fdb','__config','__state','__encapsulation','__inter_instance_policies','__table_connections','__interfaces','__tables','__connection_points','__mpls','__segment_routing','__vlans','__policy_forwarding','__afts','__protocols',)

  _yang_name = 'network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__tables = YANGDynClass(base=tables.tables, is_container='container', yang_name="tables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__fdb = YANGDynClass(base=fdb.fdb, is_container='container', yang_name="fdb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    self.__afts = YANGDynClass(base=afts.afts, is_container='container', yang_name="afts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__interfaces = YANGDynClass(base=interfaces.interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__mpls = YANGDynClass(base=mpls.mpls, is_container='container', yang_name="mpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__table_connections = YANGDynClass(base=table_connections.table_connections, is_container='container', yang_name="table-connections", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__connection_points = YANGDynClass(base=connection_points.connection_points, is_container='container', yang_name="connection-points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__inter_instance_policies = YANGDynClass(base=inter_instance_policies.inter_instance_policies, is_container='container', yang_name="inter-instance-policies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__encapsulation = YANGDynClass(base=encapsulation.encapsulation, is_container='container', yang_name="encapsulation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__segment_routing = YANGDynClass(base=segment_routing.segment_routing, is_container='container', yang_name="segment-routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__vlans = YANGDynClass(base=vlans.vlans, is_container='container', yang_name="vlans", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__protocols = YANGDynClass(base=protocols.protocols, is_container='container', yang_name="protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__policy_forwarding = YANGDynClass(base=policy_forwarding.policy_forwarding, is_container='container', yang_name="policy-forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'network-instances', u'network-instance']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /network_instances/network_instance/name (leafref)

    YANG Description: A unique name identifying the network instance
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /network_instances/network_instance/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: A unique name identifying the network instance
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)


  def _get_fdb(self):
    """
    Getter method for fdb, mapped from YANG variable /network_instances/network_instance/fdb (container)

    YANG Description: Operational state and configuration parameters relating to
the forwarding database of the network instance
    """
    return self.__fdb
      
  def _set_fdb(self, v, load=False):
    """
    Setter method for fdb, mapped from YANG variable /network_instances/network_instance/fdb (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fdb is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fdb() directly.

    YANG Description: Operational state and configuration parameters relating to
the forwarding database of the network instance
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=fdb.fdb, is_container='container', yang_name="fdb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fdb must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=fdb.fdb, is_container='container', yang_name="fdb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__fdb = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fdb(self):
    self.__fdb = YANGDynClass(base=fdb.fdb, is_container='container', yang_name="fdb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /network_instances/network_instance/config (container)

    YANG Description: Configuration parameters relating to a network
instance
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /network_instances/network_instance/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration parameters relating to a network
instance
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /network_instances/network_instance/state (container)

    YANG Description: Operational state parameters relating to a network
instance
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /network_instances/network_instance/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state parameters relating to a network
instance
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_encapsulation(self):
    """
    Getter method for encapsulation, mapped from YANG variable /network_instances/network_instance/encapsulation (container)

    YANG Description: Configuration parameters relating to the encapsulation
used for the network instance
    """
    return self.__encapsulation
      
  def _set_encapsulation(self, v, load=False):
    """
    Setter method for encapsulation, mapped from YANG variable /network_instances/network_instance/encapsulation (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_encapsulation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_encapsulation() directly.

    YANG Description: Configuration parameters relating to the encapsulation
used for the network instance
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=encapsulation.encapsulation, is_container='container', yang_name="encapsulation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """encapsulation must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=encapsulation.encapsulation, is_container='container', yang_name="encapsulation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__encapsulation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_encapsulation(self):
    self.__encapsulation = YANGDynClass(base=encapsulation.encapsulation, is_container='container', yang_name="encapsulation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_inter_instance_policies(self):
    """
    Getter method for inter_instance_policies, mapped from YANG variable /network_instances/network_instance/inter_instance_policies (container)

    YANG Description: Policies dictating how RIB or FIB entries are imported
to and exported from this instance
    """
    return self.__inter_instance_policies
      
  def _set_inter_instance_policies(self, v, load=False):
    """
    Setter method for inter_instance_policies, mapped from YANG variable /network_instances/network_instance/inter_instance_policies (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inter_instance_policies is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inter_instance_policies() directly.

    YANG Description: Policies dictating how RIB or FIB entries are imported
to and exported from this instance
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=inter_instance_policies.inter_instance_policies, is_container='container', yang_name="inter-instance-policies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inter_instance_policies must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=inter_instance_policies.inter_instance_policies, is_container='container', yang_name="inter-instance-policies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__inter_instance_policies = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inter_instance_policies(self):
    self.__inter_instance_policies = YANGDynClass(base=inter_instance_policies.inter_instance_policies, is_container='container', yang_name="inter-instance-policies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_table_connections(self):
    """
    Getter method for table_connections, mapped from YANG variable /network_instances/network_instance/table_connections (container)

    YANG Description: Policies dictating how RIB or FIB entries are propagated
between tables
    """
    return self.__table_connections
      
  def _set_table_connections(self, v, load=False):
    """
    Setter method for table_connections, mapped from YANG variable /network_instances/network_instance/table_connections (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_table_connections is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_table_connections() directly.

    YANG Description: Policies dictating how RIB or FIB entries are propagated
between tables
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=table_connections.table_connections, is_container='container', yang_name="table-connections", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """table_connections must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=table_connections.table_connections, is_container='container', yang_name="table-connections", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__table_connections = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_table_connections(self):
    self.__table_connections = YANGDynClass(base=table_connections.table_connections, is_container='container', yang_name="table-connections", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_interfaces(self):
    """
    Getter method for interfaces, mapped from YANG variable /network_instances/network_instance/interfaces (container)

    YANG Description: The interfaces that are associated with this network
instance
    """
    return self.__interfaces
      
  def _set_interfaces(self, v, load=False):
    """
    Setter method for interfaces, mapped from YANG variable /network_instances/network_instance/interfaces (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interfaces() directly.

    YANG Description: The interfaces that are associated with this network
instance
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=interfaces.interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interfaces must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=interfaces.interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__interfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interfaces(self):
    self.__interfaces = YANGDynClass(base=interfaces.interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_tables(self):
    """
    Getter method for tables, mapped from YANG variable /network_instances/network_instance/tables (container)

    YANG Description: The routing tables that are managed by this network
instance
    """
    return self.__tables
      
  def _set_tables(self, v, load=False):
    """
    Setter method for tables, mapped from YANG variable /network_instances/network_instance/tables (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tables is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tables() directly.

    YANG Description: The routing tables that are managed by this network
instance
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=tables.tables, is_container='container', yang_name="tables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tables must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=tables.tables, is_container='container', yang_name="tables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__tables = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tables(self):
    self.__tables = YANGDynClass(base=tables.tables, is_container='container', yang_name="tables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_connection_points(self):
    """
    Getter method for connection_points, mapped from YANG variable /network_instances/network_instance/connection_points (container)

    YANG Description: The set of connection points within a forwarding
instance
    """
    return self.__connection_points
      
  def _set_connection_points(self, v, load=False):
    """
    Setter method for connection_points, mapped from YANG variable /network_instances/network_instance/connection_points (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connection_points is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connection_points() directly.

    YANG Description: The set of connection points within a forwarding
instance
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=connection_points.connection_points, is_container='container', yang_name="connection-points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connection_points must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=connection_points.connection_points, is_container='container', yang_name="connection-points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__connection_points = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connection_points(self):
    self.__connection_points = YANGDynClass(base=connection_points.connection_points, is_container='container', yang_name="connection-points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_mpls(self):
    """
    Getter method for mpls, mapped from YANG variable /network_instances/network_instance/mpls (container)

    YANG Description: Anchor point for mpls configuration and operational
data
    """
    return self.__mpls
      
  def _set_mpls(self, v, load=False):
    """
    Setter method for mpls, mapped from YANG variable /network_instances/network_instance/mpls (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mpls is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mpls() directly.

    YANG Description: Anchor point for mpls configuration and operational
data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=mpls.mpls, is_container='container', yang_name="mpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mpls must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=mpls.mpls, is_container='container', yang_name="mpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__mpls = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mpls(self):
    self.__mpls = YANGDynClass(base=mpls.mpls, is_container='container', yang_name="mpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_segment_routing(self):
    """
    Getter method for segment_routing, mapped from YANG variable /network_instances/network_instance/segment_routing (container)

    YANG Description: Configuration and operational state parameters relating to
segment routing.
    """
    return self.__segment_routing
      
  def _set_segment_routing(self, v, load=False):
    """
    Setter method for segment_routing, mapped from YANG variable /network_instances/network_instance/segment_routing (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_segment_routing is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_segment_routing() directly.

    YANG Description: Configuration and operational state parameters relating to
segment routing.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=segment_routing.segment_routing, is_container='container', yang_name="segment-routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """segment_routing must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=segment_routing.segment_routing, is_container='container', yang_name="segment-routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__segment_routing = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_segment_routing(self):
    self.__segment_routing = YANGDynClass(base=segment_routing.segment_routing, is_container='container', yang_name="segment-routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_vlans(self):
    """
    Getter method for vlans, mapped from YANG variable /network_instances/network_instance/vlans (container)

    YANG Description: Container for VLAN configuration and state
variables
    """
    return self.__vlans
      
  def _set_vlans(self, v, load=False):
    """
    Setter method for vlans, mapped from YANG variable /network_instances/network_instance/vlans (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlans is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlans() directly.

    YANG Description: Container for VLAN configuration and state
variables
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=vlans.vlans, is_container='container', yang_name="vlans", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlans must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=vlans.vlans, is_container='container', yang_name="vlans", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__vlans = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlans(self):
    self.__vlans = YANGDynClass(base=vlans.vlans, is_container='container', yang_name="vlans", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_policy_forwarding(self):
    """
    Getter method for policy_forwarding, mapped from YANG variable /network_instances/network_instance/policy_forwarding (container)

    YANG Description: Configuration and operational state relating to policy-forwarding within
a network instance.
    """
    return self.__policy_forwarding
      
  def _set_policy_forwarding(self, v, load=False):
    """
    Setter method for policy_forwarding, mapped from YANG variable /network_instances/network_instance/policy_forwarding (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy_forwarding is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy_forwarding() directly.

    YANG Description: Configuration and operational state relating to policy-forwarding within
a network instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=policy_forwarding.policy_forwarding, is_container='container', yang_name="policy-forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policy_forwarding must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=policy_forwarding.policy_forwarding, is_container='container', yang_name="policy-forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__policy_forwarding = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policy_forwarding(self):
    self.__policy_forwarding = YANGDynClass(base=policy_forwarding.policy_forwarding, is_container='container', yang_name="policy-forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_afts(self):
    """
    Getter method for afts, mapped from YANG variable /network_instances/network_instance/afts (container)

    YANG Description: The abstract forwarding tables (AFTs) that are associated
with the network instance. An AFT is instantiated per-protocol
running within the network-instance - such that one exists for
IPv4 Unicast, IPv6 Unicast, MPLS, L2 forwarding entries, etc.
A forwarding entry within the FIB has a set of next-hops,
which may be a reference to an entry within another table -
e.g., where a Layer 3 next-hop has an associated Layer 2
forwarding entry.
    """
    return self.__afts
      
  def _set_afts(self, v, load=False):
    """
    Setter method for afts, mapped from YANG variable /network_instances/network_instance/afts (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_afts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_afts() directly.

    YANG Description: The abstract forwarding tables (AFTs) that are associated
with the network instance. An AFT is instantiated per-protocol
running within the network-instance - such that one exists for
IPv4 Unicast, IPv6 Unicast, MPLS, L2 forwarding entries, etc.
A forwarding entry within the FIB has a set of next-hops,
which may be a reference to an entry within another table -
e.g., where a Layer 3 next-hop has an associated Layer 2
forwarding entry.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=afts.afts, is_container='container', yang_name="afts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """afts must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=afts.afts, is_container='container', yang_name="afts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__afts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_afts(self):
    self.__afts = YANGDynClass(base=afts.afts, is_container='container', yang_name="afts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_protocols(self):
    """
    Getter method for protocols, mapped from YANG variable /network_instances/network_instance/protocols (container)

    YANG Description: The routing protocols that are enabled for this
network-instance.
    """
    return self.__protocols
      
  def _set_protocols(self, v, load=False):
    """
    Setter method for protocols, mapped from YANG variable /network_instances/network_instance/protocols (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocols is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocols() directly.

    YANG Description: The routing protocols that are enabled for this
network-instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=protocols.protocols, is_container='container', yang_name="protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocols must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=protocols.protocols, is_container='container', yang_name="protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__protocols = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocols(self):
    self.__protocols = YANGDynClass(base=protocols.protocols, is_container='container', yang_name="protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  fdb = __builtin__.property(_get_fdb, _set_fdb)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  encapsulation = __builtin__.property(_get_encapsulation, _set_encapsulation)
  inter_instance_policies = __builtin__.property(_get_inter_instance_policies, _set_inter_instance_policies)
  table_connections = __builtin__.property(_get_table_connections, _set_table_connections)
  interfaces = __builtin__.property(_get_interfaces, _set_interfaces)
  tables = __builtin__.property(_get_tables, _set_tables)
  connection_points = __builtin__.property(_get_connection_points, _set_connection_points)
  mpls = __builtin__.property(_get_mpls, _set_mpls)
  segment_routing = __builtin__.property(_get_segment_routing, _set_segment_routing)
  vlans = __builtin__.property(_get_vlans, _set_vlans)
  policy_forwarding = __builtin__.property(_get_policy_forwarding, _set_policy_forwarding)
  afts = __builtin__.property(_get_afts, _set_afts)
  protocols = __builtin__.property(_get_protocols, _set_protocols)


  _pyangbind_elements = {'name': name, 'fdb': fdb, 'config': config, 'state': state, 'encapsulation': encapsulation, 'inter_instance_policies': inter_instance_policies, 'table_connections': table_connections, 'interfaces': interfaces, 'tables': tables, 'connection_points': connection_points, 'mpls': mpls, 'segment_routing': segment_routing, 'vlans': vlans, 'policy_forwarding': policy_forwarding, 'afts': afts, 'protocols': protocols, }


