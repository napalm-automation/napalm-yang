
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
  unicode = str
elif six.PY2:
  import __builtin__

from . import ipv4_unicast
from . import ipv6_unicast
from . import policy_forwarding
from . import mpls
from . import ethernet
class afts(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance - based on the path /network-instances/network-instance/afts. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The abstract forwarding tables (AFTs) that are associated
with the network instance. An AFT is instantiated per-protocol
running within the network-instance - such that one exists for
IPv4 Unicast, IPv6 Unicast, MPLS, L2 forwarding entries, etc.
A forwarding entry within the FIB has a set of next-hops,
which may be a reference to an entry within another table -
e.g., where a Layer 3 next-hop has an associated Layer 2
forwarding entry.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__ipv4_unicast','__ipv6_unicast','__policy_forwarding','__mpls','__ethernet',)

  _yang_name = 'afts'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ipv6_unicast = YANGDynClass(base=ipv6_unicast.ipv6_unicast, is_container='container', yang_name="ipv6-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__ethernet = YANGDynClass(base=ethernet.ethernet, is_container='container', yang_name="ethernet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__mpls = YANGDynClass(base=mpls.mpls, is_container='container', yang_name="mpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__policy_forwarding = YANGDynClass(base=policy_forwarding.policy_forwarding, is_container='container', yang_name="policy-forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__ipv4_unicast = YANGDynClass(base=ipv4_unicast.ipv4_unicast, is_container='container', yang_name="ipv4-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'network-instances', u'network-instance', u'afts']

  def _get_ipv4_unicast(self):
    """
    Getter method for ipv4_unicast, mapped from YANG variable /network_instances/network_instance/afts/ipv4_unicast (container)

    YANG Description: The abstract forwarding table for IPv4 unicast. Entries
within this table are uniquely keyed on the IPv4 unicast
destination prefix which is matched by ingress packets.

The data set represented by the IPv4 Unicast AFT is the set
of entries from the IPv4 unicast RIB that have been selected
for installation into the FIB of the device exporting the
data structure.
    """
    return self.__ipv4_unicast
      
  def _set_ipv4_unicast(self, v, load=False):
    """
    Setter method for ipv4_unicast, mapped from YANG variable /network_instances/network_instance/afts/ipv4_unicast (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4_unicast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4_unicast() directly.

    YANG Description: The abstract forwarding table for IPv4 unicast. Entries
within this table are uniquely keyed on the IPv4 unicast
destination prefix which is matched by ingress packets.

The data set represented by the IPv4 Unicast AFT is the set
of entries from the IPv4 unicast RIB that have been selected
for installation into the FIB of the device exporting the
data structure.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ipv4_unicast.ipv4_unicast, is_container='container', yang_name="ipv4-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4_unicast must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ipv4_unicast.ipv4_unicast, is_container='container', yang_name="ipv4-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__ipv4_unicast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4_unicast(self):
    self.__ipv4_unicast = YANGDynClass(base=ipv4_unicast.ipv4_unicast, is_container='container', yang_name="ipv4-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_ipv6_unicast(self):
    """
    Getter method for ipv6_unicast, mapped from YANG variable /network_instances/network_instance/afts/ipv6_unicast (container)

    YANG Description: The abstract forwarding table for IPv6 unicast. Entries
within this table are uniquely keyed on the IPv6 unicast
destination prefix which is matched by ingress packets.

The data set represented by the IPv6 Unicast AFTis the set
of entries within the IPv6 RIB that 
    """
    return self.__ipv6_unicast
      
  def _set_ipv6_unicast(self, v, load=False):
    """
    Setter method for ipv6_unicast, mapped from YANG variable /network_instances/network_instance/afts/ipv6_unicast (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_unicast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_unicast() directly.

    YANG Description: The abstract forwarding table for IPv6 unicast. Entries
within this table are uniquely keyed on the IPv6 unicast
destination prefix which is matched by ingress packets.

The data set represented by the IPv6 Unicast AFTis the set
of entries within the IPv6 RIB that 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ipv6_unicast.ipv6_unicast, is_container='container', yang_name="ipv6-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_unicast must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ipv6_unicast.ipv6_unicast, is_container='container', yang_name="ipv6-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__ipv6_unicast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_unicast(self):
    self.__ipv6_unicast = YANGDynClass(base=ipv6_unicast.ipv6_unicast, is_container='container', yang_name="ipv6-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_policy_forwarding(self):
    """
    Getter method for policy_forwarding, mapped from YANG variable /network_instances/network_instance/afts/policy_forwarding (container)

    YANG Description: The abstract forwarding table for policy-based forwarding
entries. Since multiple match criteria can be utilised
within a policy-based forwarding rule, this AFT provides a
flexible match criteria, and is indexed based on an
arbitrary 64-bit index. Entries within the AFT may match on
multiple field types (e.g., L4 header fields, as well as L2
fields).

Examples of entries within this table are:
 - IPv4 policy-based routing based on DSCP.
 - MPLS policy-based forwarding entries.
    """
    return self.__policy_forwarding
      
  def _set_policy_forwarding(self, v, load=False):
    """
    Setter method for policy_forwarding, mapped from YANG variable /network_instances/network_instance/afts/policy_forwarding (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy_forwarding is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy_forwarding() directly.

    YANG Description: The abstract forwarding table for policy-based forwarding
entries. Since multiple match criteria can be utilised
within a policy-based forwarding rule, this AFT provides a
flexible match criteria, and is indexed based on an
arbitrary 64-bit index. Entries within the AFT may match on
multiple field types (e.g., L4 header fields, as well as L2
fields).

Examples of entries within this table are:
 - IPv4 policy-based routing based on DSCP.
 - MPLS policy-based forwarding entries.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=policy_forwarding.policy_forwarding, is_container='container', yang_name="policy-forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policy_forwarding must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=policy_forwarding.policy_forwarding, is_container='container', yang_name="policy-forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__policy_forwarding = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policy_forwarding(self):
    self.__policy_forwarding = YANGDynClass(base=policy_forwarding.policy_forwarding, is_container='container', yang_name="policy-forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_mpls(self):
    """
    Getter method for mpls, mapped from YANG variable /network_instances/network_instance/afts/mpls (container)

    YANG Description: The abstract forwarding table for MPLS label based
forwarding entries. Entries within the table are keyed based
on the top-most MPLS label in the stack on the ingress
packet.
    """
    return self.__mpls
      
  def _set_mpls(self, v, load=False):
    """
    Setter method for mpls, mapped from YANG variable /network_instances/network_instance/afts/mpls (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mpls is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mpls() directly.

    YANG Description: The abstract forwarding table for MPLS label based
forwarding entries. Entries within the table are keyed based
on the top-most MPLS label in the stack on the ingress
packet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=mpls.mpls, is_container='container', yang_name="mpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mpls must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=mpls.mpls, is_container='container', yang_name="mpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__mpls = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mpls(self):
    self.__mpls = YANGDynClass(base=mpls.mpls, is_container='container', yang_name="mpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_ethernet(self):
    """
    Getter method for ethernet, mapped from YANG variable /network_instances/network_instance/afts/ethernet (container)

    YANG Description: The abstract forwarding table for Ethernet based forwarding
entries. Entries within the table are keyed based on the 
destination MAC address on the ingress packet.
    """
    return self.__ethernet
      
  def _set_ethernet(self, v, load=False):
    """
    Setter method for ethernet, mapped from YANG variable /network_instances/network_instance/afts/ethernet (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ethernet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ethernet() directly.

    YANG Description: The abstract forwarding table for Ethernet based forwarding
entries. Entries within the table are keyed based on the 
destination MAC address on the ingress packet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ethernet.ethernet, is_container='container', yang_name="ethernet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ethernet must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ethernet.ethernet, is_container='container', yang_name="ethernet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__ethernet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ethernet(self):
    self.__ethernet = YANGDynClass(base=ethernet.ethernet, is_container='container', yang_name="ethernet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)

  ipv4_unicast = __builtin__.property(_get_ipv4_unicast, _set_ipv4_unicast)
  ipv6_unicast = __builtin__.property(_get_ipv6_unicast, _set_ipv6_unicast)
  policy_forwarding = __builtin__.property(_get_policy_forwarding, _set_policy_forwarding)
  mpls = __builtin__.property(_get_mpls, _set_mpls)
  ethernet = __builtin__.property(_get_ethernet, _set_ethernet)


  _pyangbind_elements = {'ipv4_unicast': ipv4_unicast, 'ipv6_unicast': ipv6_unicast, 'policy_forwarding': policy_forwarding, 'mpls': mpls, 'ethernet': ethernet, }


from . import ipv4_unicast
from . import ipv6_unicast
from . import policy_forwarding
from . import mpls
from . import ethernet
class afts(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance-l2 - based on the path /network-instances/network-instance/afts. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The abstract forwarding tables (AFTs) that are associated
with the network instance. An AFT is instantiated per-protocol
running within the network-instance - such that one exists for
IPv4 Unicast, IPv6 Unicast, MPLS, L2 forwarding entries, etc.
A forwarding entry within the FIB has a set of next-hops,
which may be a reference to an entry within another table -
e.g., where a Layer 3 next-hop has an associated Layer 2
forwarding entry.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__ipv4_unicast','__ipv6_unicast','__policy_forwarding','__mpls','__ethernet',)

  _yang_name = 'afts'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ipv6_unicast = YANGDynClass(base=ipv6_unicast.ipv6_unicast, is_container='container', yang_name="ipv6-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__ethernet = YANGDynClass(base=ethernet.ethernet, is_container='container', yang_name="ethernet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__mpls = YANGDynClass(base=mpls.mpls, is_container='container', yang_name="mpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__policy_forwarding = YANGDynClass(base=policy_forwarding.policy_forwarding, is_container='container', yang_name="policy-forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__ipv4_unicast = YANGDynClass(base=ipv4_unicast.ipv4_unicast, is_container='container', yang_name="ipv4-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'network-instances', u'network-instance', u'afts']

  def _get_ipv4_unicast(self):
    """
    Getter method for ipv4_unicast, mapped from YANG variable /network_instances/network_instance/afts/ipv4_unicast (container)

    YANG Description: The abstract forwarding table for IPv4 unicast. Entries
within this table are uniquely keyed on the IPv4 unicast
destination prefix which is matched by ingress packets.

The data set represented by the IPv4 Unicast AFT is the set
of entries from the IPv4 unicast RIB that have been selected
for installation into the FIB of the device exporting the
data structure.
    """
    return self.__ipv4_unicast
      
  def _set_ipv4_unicast(self, v, load=False):
    """
    Setter method for ipv4_unicast, mapped from YANG variable /network_instances/network_instance/afts/ipv4_unicast (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4_unicast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4_unicast() directly.

    YANG Description: The abstract forwarding table for IPv4 unicast. Entries
within this table are uniquely keyed on the IPv4 unicast
destination prefix which is matched by ingress packets.

The data set represented by the IPv4 Unicast AFT is the set
of entries from the IPv4 unicast RIB that have been selected
for installation into the FIB of the device exporting the
data structure.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ipv4_unicast.ipv4_unicast, is_container='container', yang_name="ipv4-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4_unicast must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ipv4_unicast.ipv4_unicast, is_container='container', yang_name="ipv4-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__ipv4_unicast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4_unicast(self):
    self.__ipv4_unicast = YANGDynClass(base=ipv4_unicast.ipv4_unicast, is_container='container', yang_name="ipv4-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_ipv6_unicast(self):
    """
    Getter method for ipv6_unicast, mapped from YANG variable /network_instances/network_instance/afts/ipv6_unicast (container)

    YANG Description: The abstract forwarding table for IPv6 unicast. Entries
within this table are uniquely keyed on the IPv6 unicast
destination prefix which is matched by ingress packets.

The data set represented by the IPv6 Unicast AFTis the set
of entries within the IPv6 RIB that 
    """
    return self.__ipv6_unicast
      
  def _set_ipv6_unicast(self, v, load=False):
    """
    Setter method for ipv6_unicast, mapped from YANG variable /network_instances/network_instance/afts/ipv6_unicast (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_unicast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_unicast() directly.

    YANG Description: The abstract forwarding table for IPv6 unicast. Entries
within this table are uniquely keyed on the IPv6 unicast
destination prefix which is matched by ingress packets.

The data set represented by the IPv6 Unicast AFTis the set
of entries within the IPv6 RIB that 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ipv6_unicast.ipv6_unicast, is_container='container', yang_name="ipv6-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_unicast must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ipv6_unicast.ipv6_unicast, is_container='container', yang_name="ipv6-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__ipv6_unicast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_unicast(self):
    self.__ipv6_unicast = YANGDynClass(base=ipv6_unicast.ipv6_unicast, is_container='container', yang_name="ipv6-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_policy_forwarding(self):
    """
    Getter method for policy_forwarding, mapped from YANG variable /network_instances/network_instance/afts/policy_forwarding (container)

    YANG Description: The abstract forwarding table for policy-based forwarding
entries. Since multiple match criteria can be utilised
within a policy-based forwarding rule, this AFT provides a
flexible match criteria, and is indexed based on an
arbitrary 64-bit index. Entries within the AFT may match on
multiple field types (e.g., L4 header fields, as well as L2
fields).

Examples of entries within this table are:
 - IPv4 policy-based routing based on DSCP.
 - MPLS policy-based forwarding entries.
    """
    return self.__policy_forwarding
      
  def _set_policy_forwarding(self, v, load=False):
    """
    Setter method for policy_forwarding, mapped from YANG variable /network_instances/network_instance/afts/policy_forwarding (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy_forwarding is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy_forwarding() directly.

    YANG Description: The abstract forwarding table for policy-based forwarding
entries. Since multiple match criteria can be utilised
within a policy-based forwarding rule, this AFT provides a
flexible match criteria, and is indexed based on an
arbitrary 64-bit index. Entries within the AFT may match on
multiple field types (e.g., L4 header fields, as well as L2
fields).

Examples of entries within this table are:
 - IPv4 policy-based routing based on DSCP.
 - MPLS policy-based forwarding entries.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=policy_forwarding.policy_forwarding, is_container='container', yang_name="policy-forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policy_forwarding must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=policy_forwarding.policy_forwarding, is_container='container', yang_name="policy-forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__policy_forwarding = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policy_forwarding(self):
    self.__policy_forwarding = YANGDynClass(base=policy_forwarding.policy_forwarding, is_container='container', yang_name="policy-forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_mpls(self):
    """
    Getter method for mpls, mapped from YANG variable /network_instances/network_instance/afts/mpls (container)

    YANG Description: The abstract forwarding table for MPLS label based
forwarding entries. Entries within the table are keyed based
on the top-most MPLS label in the stack on the ingress
packet.
    """
    return self.__mpls
      
  def _set_mpls(self, v, load=False):
    """
    Setter method for mpls, mapped from YANG variable /network_instances/network_instance/afts/mpls (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mpls is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mpls() directly.

    YANG Description: The abstract forwarding table for MPLS label based
forwarding entries. Entries within the table are keyed based
on the top-most MPLS label in the stack on the ingress
packet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=mpls.mpls, is_container='container', yang_name="mpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mpls must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=mpls.mpls, is_container='container', yang_name="mpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__mpls = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mpls(self):
    self.__mpls = YANGDynClass(base=mpls.mpls, is_container='container', yang_name="mpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_ethernet(self):
    """
    Getter method for ethernet, mapped from YANG variable /network_instances/network_instance/afts/ethernet (container)

    YANG Description: The abstract forwarding table for Ethernet based forwarding
entries. Entries within the table are keyed based on the 
destination MAC address on the ingress packet.
    """
    return self.__ethernet
      
  def _set_ethernet(self, v, load=False):
    """
    Setter method for ethernet, mapped from YANG variable /network_instances/network_instance/afts/ethernet (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ethernet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ethernet() directly.

    YANG Description: The abstract forwarding table for Ethernet based forwarding
entries. Entries within the table are keyed based on the 
destination MAC address on the ingress packet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ethernet.ethernet, is_container='container', yang_name="ethernet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ethernet must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ethernet.ethernet, is_container='container', yang_name="ethernet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__ethernet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ethernet(self):
    self.__ethernet = YANGDynClass(base=ethernet.ethernet, is_container='container', yang_name="ethernet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)

  ipv4_unicast = __builtin__.property(_get_ipv4_unicast, _set_ipv4_unicast)
  ipv6_unicast = __builtin__.property(_get_ipv6_unicast, _set_ipv6_unicast)
  policy_forwarding = __builtin__.property(_get_policy_forwarding, _set_policy_forwarding)
  mpls = __builtin__.property(_get_mpls, _set_mpls)
  ethernet = __builtin__.property(_get_ethernet, _set_ethernet)


  _pyangbind_elements = {'ipv4_unicast': ipv4_unicast, 'ipv6_unicast': ipv6_unicast, 'policy_forwarding': policy_forwarding, 'mpls': mpls, 'ethernet': ethernet, }


