
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance - based on the path /network-instances/network-instance/afts/aft/entries/entry/next-hops/next-hop/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state parameters relating to the AFT
next-hop entry
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__index','__weight','__ip_address','__mac_address','__popped_mpls_label_stack','__pushed_mpls_label_stack','__decapsulate_header','__encapsulate_header','__origin_protocol',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint64', is_config=False)
    self.__weight = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)
    self.__popped_mpls_label_stack = YANGDynClass(base=TypedListType(allowed_type=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'16..1048575']}),RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'NO_LABEL': {}, u'IPV6_EXPLICIT_NULL': {'value': 2}, u'ENTROPY_LABEL_INDICATOR': {'value': 7}, u'IPV4_EXPLICIT_NULL': {'value': 0}, u'ROUTER_ALERT': {'value': 1}, u'IMPLICIT_NULL': {'value': 3}},),]), is_leaf=False, yang_name="popped-mpls-label-stack", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-mplst:mpls-label', is_config=False)
    self.__encapsulate_header = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'GRE': {}, u'MPLS': {}, u'IPV4': {}, u'IPV6': {}},), is_leaf=True, yang_name="encapsulate-header", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-aftt:encapsulation-header-type', is_config=False)
    self.__decapsulate_header = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'GRE': {}, u'MPLS': {}, u'IPV4': {}, u'IPV6': {}},), is_leaf=True, yang_name="decapsulate-header", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-aftt:encapsulation-header-type', is_config=False)
    self.__mac_address = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:mac-address', is_config=False)
    self.__ip_address = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': u'[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': u'[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='inet:ip-address-no-zone', is_config=False)
    self.__origin_protocol = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-pt:ISIS': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:ISIS': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'ISIS': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'DIRECTLY_CONNECTED': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:OSPF': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:OSPF3': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:STATIC': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:DIRECTLY_CONNECTED': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:BGP': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:LOCAL_AGGREGATE': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'BGP': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:STATIC': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'LOCAL_AGGREGATE': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:OSPF3': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'STATIC': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:BGP': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:LOCAL_AGGREGATE': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'OSPF': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:OSPF': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'OSPF3': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:DIRECTLY_CONNECTED': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}},), is_leaf=True, yang_name="origin-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=False)
    self.__pushed_mpls_label_stack = YANGDynClass(base=TypedListType(allowed_type=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'16..1048575']}),RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'NO_LABEL': {}, u'IPV6_EXPLICIT_NULL': {'value': 2}, u'ENTROPY_LABEL_INDICATOR': {'value': 7}, u'IPV4_EXPLICIT_NULL': {'value': 0}, u'ROUTER_ALERT': {'value': 1}, u'IMPLICIT_NULL': {'value': 3}},),]), is_leaf=False, yang_name="pushed-mpls-label-stack", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-mplst:mpls-label', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'network-instances', u'network-instance', u'afts', u'aft', u'entries', u'entry', u'next-hops', u'next-hop', u'state']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /network_instances/network_instance/afts/aft/entries/entry/next_hops/next_hop/state/index (uint64)

    YANG Description: A unique entry for the next-hop
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /network_instances/network_instance/afts/aft/entries/entry/next_hops/next_hop/state/index (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: A unique entry for the next-hop
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint64', is_config=False)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint64', is_config=False)


  def _get_weight(self):
    """
    Getter method for weight, mapped from YANG variable /network_instances/network_instance/afts/aft/entries/entry/next_hops/next_hop/state/weight (uint32)

    YANG Description: The weight of the next-hop. Traffic is balanced according to
the ratio described by the relative weights of the next hops
that exist for the AFT entry. Note that all next-hops that are
specified are assumed to be active next-hops and therefore
eligible (and selected) to be installed in the FIB, and hence
used for packet forwarding.
    """
    return self.__weight
      
  def _set_weight(self, v, load=False):
    """
    Setter method for weight, mapped from YANG variable /network_instances/network_instance/afts/aft/entries/entry/next_hops/next_hop/state/weight (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_weight is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_weight() directly.

    YANG Description: The weight of the next-hop. Traffic is balanced according to
the ratio described by the relative weights of the next hops
that exist for the AFT entry. Note that all next-hops that are
specified are assumed to be active next-hops and therefore
eligible (and selected) to be installed in the FIB, and hence
used for packet forwarding.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """weight must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)""",
        })

    self.__weight = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_weight(self):
    self.__weight = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)


  def _get_ip_address(self):
    """
    Getter method for ip_address, mapped from YANG variable /network_instances/network_instance/afts/aft/entries/entry/next_hops/next_hop/state/ip_address (inet:ip-address-no-zone)

    YANG Description: The IP address of the next-hop system.
    """
    return self.__ip_address
      
  def _set_ip_address(self, v, load=False):
    """
    Setter method for ip_address, mapped from YANG variable /network_instances/network_instance/afts/aft/entries/entry/next_hops/next_hop/state/ip_address (inet:ip-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_address() directly.

    YANG Description: The IP address of the next-hop system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': u'[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': u'[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='inet:ip-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_address must be of a type compatible with inet:ip-address-no-zone""",
          'defined-type': "inet:ip-address-no-zone",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': u'[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': u'[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='inet:ip-address-no-zone', is_config=False)""",
        })

    self.__ip_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_address(self):
    self.__ip_address = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': u'[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': u'[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='inet:ip-address-no-zone', is_config=False)


  def _get_mac_address(self):
    """
    Getter method for mac_address, mapped from YANG variable /network_instances/network_instance/afts/aft/entries/entry/next_hops/next_hop/state/mac_address (yang:mac-address)

    YANG Description: The MAC address of the next-hop if resolved by the local
network instance.
    """
    return self.__mac_address
      
  def _set_mac_address(self, v, load=False):
    """
    Setter method for mac_address, mapped from YANG variable /network_instances/network_instance/afts/aft/entries/entry/next_hops/next_hop/state/mac_address (yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac_address() directly.

    YANG Description: The MAC address of the next-hop if resolved by the local
network instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:mac-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac_address must be of a type compatible with yang:mac-address""",
          'defined-type': "yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:mac-address', is_config=False)""",
        })

    self.__mac_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac_address(self):
    self.__mac_address = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:mac-address', is_config=False)


  def _get_popped_mpls_label_stack(self):
    """
    Getter method for popped_mpls_label_stack, mapped from YANG variable /network_instances/network_instance/afts/aft/entries/entry/next_hops/next_hop/state/popped_mpls_label_stack (oc-mplst:mpls-label)

    YANG Description: The MPLS label stack to be popped from the packet when
switched by the system. The stack is encoding as a leaf-list
whereby the other of the entries is such that the first entry
is the label lowest down the label stack to be popped.

If the local system pops the outer-most label 400, then the
value of this list is [400,]. If the local system removes two
labels, the outer-most being 500, and the second of which is
500, then the value of the list is [500, 400].

A swap operation is reflected by entries in the
popped-mpls-label-stack and pushed-mpls-label-stack nodes.
    """
    return self.__popped_mpls_label_stack
      
  def _set_popped_mpls_label_stack(self, v, load=False):
    """
    Setter method for popped_mpls_label_stack, mapped from YANG variable /network_instances/network_instance/afts/aft/entries/entry/next_hops/next_hop/state/popped_mpls_label_stack (oc-mplst:mpls-label)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_popped_mpls_label_stack is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_popped_mpls_label_stack() directly.

    YANG Description: The MPLS label stack to be popped from the packet when
switched by the system. The stack is encoding as a leaf-list
whereby the other of the entries is such that the first entry
is the label lowest down the label stack to be popped.

If the local system pops the outer-most label 400, then the
value of this list is [400,]. If the local system removes two
labels, the outer-most being 500, and the second of which is
500, then the value of the list is [500, 400].

A swap operation is reflected by entries in the
popped-mpls-label-stack and pushed-mpls-label-stack nodes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=TypedListType(allowed_type=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'16..1048575']}),RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'NO_LABEL': {}, u'IPV6_EXPLICIT_NULL': {'value': 2}, u'ENTROPY_LABEL_INDICATOR': {'value': 7}, u'IPV4_EXPLICIT_NULL': {'value': 0}, u'ROUTER_ALERT': {'value': 1}, u'IMPLICIT_NULL': {'value': 3}},),]), is_leaf=False, yang_name="popped-mpls-label-stack", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-mplst:mpls-label', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """popped_mpls_label_stack must be of a type compatible with oc-mplst:mpls-label""",
          'defined-type': "oc-mplst:mpls-label",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'16..1048575']}),RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'NO_LABEL': {}, u'IPV6_EXPLICIT_NULL': {'value': 2}, u'ENTROPY_LABEL_INDICATOR': {'value': 7}, u'IPV4_EXPLICIT_NULL': {'value': 0}, u'ROUTER_ALERT': {'value': 1}, u'IMPLICIT_NULL': {'value': 3}},),]), is_leaf=False, yang_name="popped-mpls-label-stack", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-mplst:mpls-label', is_config=False)""",
        })

    self.__popped_mpls_label_stack = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_popped_mpls_label_stack(self):
    self.__popped_mpls_label_stack = YANGDynClass(base=TypedListType(allowed_type=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'16..1048575']}),RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'NO_LABEL': {}, u'IPV6_EXPLICIT_NULL': {'value': 2}, u'ENTROPY_LABEL_INDICATOR': {'value': 7}, u'IPV4_EXPLICIT_NULL': {'value': 0}, u'ROUTER_ALERT': {'value': 1}, u'IMPLICIT_NULL': {'value': 3}},),]), is_leaf=False, yang_name="popped-mpls-label-stack", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-mplst:mpls-label', is_config=False)


  def _get_pushed_mpls_label_stack(self):
    """
    Getter method for pushed_mpls_label_stack, mapped from YANG variable /network_instances/network_instance/afts/aft/entries/entry/next_hops/next_hop/state/pushed_mpls_label_stack (oc-mplst:mpls-label)

    YANG Description: The MPLS label stack imposed when forwarding packets to the
next-hop
- the stack is encoded as a leaf list whereby the order of the
 entries is such that the first entry in the list is the
 label at the bottom of the stack to be pushed.

To this end, a packet which is to forwarded to a device using
a service label of 42, and a transport label of 8072 will be
represented with a label stack list of [42, 8072].

The MPLS label stack list is ordered by the user, such that no
system re-ordering of leaves is permitted by the system.

A swap operation is reflected by entries in the
popped-mpls-label-stack and pushed-mpls-label-stack nodes.
    """
    return self.__pushed_mpls_label_stack
      
  def _set_pushed_mpls_label_stack(self, v, load=False):
    """
    Setter method for pushed_mpls_label_stack, mapped from YANG variable /network_instances/network_instance/afts/aft/entries/entry/next_hops/next_hop/state/pushed_mpls_label_stack (oc-mplst:mpls-label)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pushed_mpls_label_stack is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pushed_mpls_label_stack() directly.

    YANG Description: The MPLS label stack imposed when forwarding packets to the
next-hop
- the stack is encoded as a leaf list whereby the order of the
 entries is such that the first entry in the list is the
 label at the bottom of the stack to be pushed.

To this end, a packet which is to forwarded to a device using
a service label of 42, and a transport label of 8072 will be
represented with a label stack list of [42, 8072].

The MPLS label stack list is ordered by the user, such that no
system re-ordering of leaves is permitted by the system.

A swap operation is reflected by entries in the
popped-mpls-label-stack and pushed-mpls-label-stack nodes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=TypedListType(allowed_type=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'16..1048575']}),RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'NO_LABEL': {}, u'IPV6_EXPLICIT_NULL': {'value': 2}, u'ENTROPY_LABEL_INDICATOR': {'value': 7}, u'IPV4_EXPLICIT_NULL': {'value': 0}, u'ROUTER_ALERT': {'value': 1}, u'IMPLICIT_NULL': {'value': 3}},),]), is_leaf=False, yang_name="pushed-mpls-label-stack", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-mplst:mpls-label', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pushed_mpls_label_stack must be of a type compatible with oc-mplst:mpls-label""",
          'defined-type': "oc-mplst:mpls-label",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'16..1048575']}),RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'NO_LABEL': {}, u'IPV6_EXPLICIT_NULL': {'value': 2}, u'ENTROPY_LABEL_INDICATOR': {'value': 7}, u'IPV4_EXPLICIT_NULL': {'value': 0}, u'ROUTER_ALERT': {'value': 1}, u'IMPLICIT_NULL': {'value': 3}},),]), is_leaf=False, yang_name="pushed-mpls-label-stack", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-mplst:mpls-label', is_config=False)""",
        })

    self.__pushed_mpls_label_stack = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pushed_mpls_label_stack(self):
    self.__pushed_mpls_label_stack = YANGDynClass(base=TypedListType(allowed_type=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'16..1048575']}),RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'NO_LABEL': {}, u'IPV6_EXPLICIT_NULL': {'value': 2}, u'ENTROPY_LABEL_INDICATOR': {'value': 7}, u'IPV4_EXPLICIT_NULL': {'value': 0}, u'ROUTER_ALERT': {'value': 1}, u'IMPLICIT_NULL': {'value': 3}},),]), is_leaf=False, yang_name="pushed-mpls-label-stack", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-mplst:mpls-label', is_config=False)


  def _get_decapsulate_header(self):
    """
    Getter method for decapsulate_header, mapped from YANG variable /network_instances/network_instance/afts/aft/entries/entry/next_hops/next_hop/state/decapsulate_header (oc-aftt:encapsulation-header-type)

    YANG Description: When forwarding a packet to the specified next-hop, the local
system performs a decapsulation of the packet - removing the
specified header type. In the case that no next-hop is
specified, the packet header is removed, and a subsequent
forwarding lookup is performed on the packet encapsulated
within the header, matched within the relevant AFT within the
specified network-instance.
    """
    return self.__decapsulate_header
      
  def _set_decapsulate_header(self, v, load=False):
    """
    Setter method for decapsulate_header, mapped from YANG variable /network_instances/network_instance/afts/aft/entries/entry/next_hops/next_hop/state/decapsulate_header (oc-aftt:encapsulation-header-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_decapsulate_header is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_decapsulate_header() directly.

    YANG Description: When forwarding a packet to the specified next-hop, the local
system performs a decapsulation of the packet - removing the
specified header type. In the case that no next-hop is
specified, the packet header is removed, and a subsequent
forwarding lookup is performed on the packet encapsulated
within the header, matched within the relevant AFT within the
specified network-instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'GRE': {}, u'MPLS': {}, u'IPV4': {}, u'IPV6': {}},), is_leaf=True, yang_name="decapsulate-header", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-aftt:encapsulation-header-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """decapsulate_header must be of a type compatible with oc-aftt:encapsulation-header-type""",
          'defined-type': "oc-aftt:encapsulation-header-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'GRE': {}, u'MPLS': {}, u'IPV4': {}, u'IPV6': {}},), is_leaf=True, yang_name="decapsulate-header", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-aftt:encapsulation-header-type', is_config=False)""",
        })

    self.__decapsulate_header = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_decapsulate_header(self):
    self.__decapsulate_header = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'GRE': {}, u'MPLS': {}, u'IPV4': {}, u'IPV6': {}},), is_leaf=True, yang_name="decapsulate-header", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-aftt:encapsulation-header-type', is_config=False)


  def _get_encapsulate_header(self):
    """
    Getter method for encapsulate_header, mapped from YANG variable /network_instances/network_instance/afts/aft/entries/entry/next_hops/next_hop/state/encapsulate_header (oc-aftt:encapsulation-header-type)

    YANG Description: When forwarding a packet to the specified next-hop the local
system performs an encapsulation of the packet - adding the
specified header type.
    """
    return self.__encapsulate_header
      
  def _set_encapsulate_header(self, v, load=False):
    """
    Setter method for encapsulate_header, mapped from YANG variable /network_instances/network_instance/afts/aft/entries/entry/next_hops/next_hop/state/encapsulate_header (oc-aftt:encapsulation-header-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_encapsulate_header is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_encapsulate_header() directly.

    YANG Description: When forwarding a packet to the specified next-hop the local
system performs an encapsulation of the packet - adding the
specified header type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'GRE': {}, u'MPLS': {}, u'IPV4': {}, u'IPV6': {}},), is_leaf=True, yang_name="encapsulate-header", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-aftt:encapsulation-header-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """encapsulate_header must be of a type compatible with oc-aftt:encapsulation-header-type""",
          'defined-type': "oc-aftt:encapsulation-header-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'GRE': {}, u'MPLS': {}, u'IPV4': {}, u'IPV6': {}},), is_leaf=True, yang_name="encapsulate-header", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-aftt:encapsulation-header-type', is_config=False)""",
        })

    self.__encapsulate_header = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_encapsulate_header(self):
    self.__encapsulate_header = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'GRE': {}, u'MPLS': {}, u'IPV4': {}, u'IPV6': {}},), is_leaf=True, yang_name="encapsulate-header", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-aftt:encapsulation-header-type', is_config=False)


  def _get_origin_protocol(self):
    """
    Getter method for origin_protocol, mapped from YANG variable /network_instances/network_instance/afts/aft/entries/entry/next_hops/next_hop/state/origin_protocol (identityref)

    YANG Description: The protocol from which the AFT entry was learned.
    """
    return self.__origin_protocol
      
  def _set_origin_protocol(self, v, load=False):
    """
    Setter method for origin_protocol, mapped from YANG variable /network_instances/network_instance/afts/aft/entries/entry/next_hops/next_hop/state/origin_protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_origin_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_origin_protocol() directly.

    YANG Description: The protocol from which the AFT entry was learned.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-pt:ISIS': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:ISIS': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'ISIS': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'DIRECTLY_CONNECTED': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:OSPF': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:OSPF3': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:STATIC': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:DIRECTLY_CONNECTED': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:BGP': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:LOCAL_AGGREGATE': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'BGP': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:STATIC': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'LOCAL_AGGREGATE': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:OSPF3': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'STATIC': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:BGP': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:LOCAL_AGGREGATE': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'OSPF': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:OSPF': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'OSPF3': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:DIRECTLY_CONNECTED': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}},), is_leaf=True, yang_name="origin-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """origin_protocol must be of a type compatible with identityref""",
          'defined-type': "openconfig-network-instance:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-pt:ISIS': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:ISIS': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'ISIS': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'DIRECTLY_CONNECTED': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:OSPF': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:OSPF3': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:STATIC': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:DIRECTLY_CONNECTED': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:BGP': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:LOCAL_AGGREGATE': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'BGP': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:STATIC': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'LOCAL_AGGREGATE': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:OSPF3': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'STATIC': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:BGP': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:LOCAL_AGGREGATE': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'OSPF': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:OSPF': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'OSPF3': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:DIRECTLY_CONNECTED': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}},), is_leaf=True, yang_name="origin-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=False)""",
        })

    self.__origin_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_origin_protocol(self):
    self.__origin_protocol = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-pt:ISIS': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:ISIS': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'ISIS': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'DIRECTLY_CONNECTED': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:OSPF': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:OSPF3': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:STATIC': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:DIRECTLY_CONNECTED': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:BGP': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:LOCAL_AGGREGATE': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'BGP': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:STATIC': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'LOCAL_AGGREGATE': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:OSPF3': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'STATIC': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:BGP': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:LOCAL_AGGREGATE': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'OSPF': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:OSPF': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'OSPF3': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:DIRECTLY_CONNECTED': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}},), is_leaf=True, yang_name="origin-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=False)

  index = __builtin__.property(_get_index)
  weight = __builtin__.property(_get_weight)
  ip_address = __builtin__.property(_get_ip_address)
  mac_address = __builtin__.property(_get_mac_address)
  popped_mpls_label_stack = __builtin__.property(_get_popped_mpls_label_stack)
  pushed_mpls_label_stack = __builtin__.property(_get_pushed_mpls_label_stack)
  decapsulate_header = __builtin__.property(_get_decapsulate_header)
  encapsulate_header = __builtin__.property(_get_encapsulate_header)
  origin_protocol = __builtin__.property(_get_origin_protocol)


  _pyangbind_elements = {'index': index, 'weight': weight, 'ip_address': ip_address, 'mac_address': mac_address, 'popped_mpls_label_stack': popped_mpls_label_stack, 'pushed_mpls_label_stack': pushed_mpls_label_stack, 'decapsulate_header': decapsulate_header, 'encapsulate_header': encapsulate_header, 'origin_protocol': origin_protocol, }


class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance-l2 - based on the path /network-instances/network-instance/afts/aft/entries/entry/next-hops/next-hop/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state parameters relating to the AFT
next-hop entry
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__index','__weight','__ip_address','__mac_address','__popped_mpls_label_stack','__pushed_mpls_label_stack','__decapsulate_header','__encapsulate_header','__origin_protocol',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint64', is_config=False)
    self.__weight = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)
    self.__popped_mpls_label_stack = YANGDynClass(base=TypedListType(allowed_type=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'16..1048575']}),RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'NO_LABEL': {}, u'IPV6_EXPLICIT_NULL': {'value': 2}, u'ENTROPY_LABEL_INDICATOR': {'value': 7}, u'IPV4_EXPLICIT_NULL': {'value': 0}, u'ROUTER_ALERT': {'value': 1}, u'IMPLICIT_NULL': {'value': 3}},),]), is_leaf=False, yang_name="popped-mpls-label-stack", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-mplst:mpls-label', is_config=False)
    self.__encapsulate_header = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'GRE': {}, u'MPLS': {}, u'IPV4': {}, u'IPV6': {}},), is_leaf=True, yang_name="encapsulate-header", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-aftt:encapsulation-header-type', is_config=False)
    self.__decapsulate_header = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'GRE': {}, u'MPLS': {}, u'IPV4': {}, u'IPV6': {}},), is_leaf=True, yang_name="decapsulate-header", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-aftt:encapsulation-header-type', is_config=False)
    self.__mac_address = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:mac-address', is_config=False)
    self.__ip_address = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': u'[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': u'[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='inet:ip-address-no-zone', is_config=False)
    self.__origin_protocol = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-pt:ISIS': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:ISIS': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'ISIS': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'DIRECTLY_CONNECTED': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:OSPF': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:OSPF3': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:STATIC': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:DIRECTLY_CONNECTED': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:BGP': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:LOCAL_AGGREGATE': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'BGP': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:STATIC': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'LOCAL_AGGREGATE': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:OSPF3': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'STATIC': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:BGP': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:LOCAL_AGGREGATE': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'OSPF': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:OSPF': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'OSPF3': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:DIRECTLY_CONNECTED': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}},), is_leaf=True, yang_name="origin-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=False)
    self.__pushed_mpls_label_stack = YANGDynClass(base=TypedListType(allowed_type=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'16..1048575']}),RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'NO_LABEL': {}, u'IPV6_EXPLICIT_NULL': {'value': 2}, u'ENTROPY_LABEL_INDICATOR': {'value': 7}, u'IPV4_EXPLICIT_NULL': {'value': 0}, u'ROUTER_ALERT': {'value': 1}, u'IMPLICIT_NULL': {'value': 3}},),]), is_leaf=False, yang_name="pushed-mpls-label-stack", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-mplst:mpls-label', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'network-instances', u'network-instance', u'afts', u'aft', u'entries', u'entry', u'next-hops', u'next-hop', u'state']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /network_instances/network_instance/afts/aft/entries/entry/next_hops/next_hop/state/index (uint64)

    YANG Description: A unique entry for the next-hop
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /network_instances/network_instance/afts/aft/entries/entry/next_hops/next_hop/state/index (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: A unique entry for the next-hop
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint64', is_config=False)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint64', is_config=False)


  def _get_weight(self):
    """
    Getter method for weight, mapped from YANG variable /network_instances/network_instance/afts/aft/entries/entry/next_hops/next_hop/state/weight (uint32)

    YANG Description: The weight of the next-hop. Traffic is balanced according to
the ratio described by the relative weights of the next hops
that exist for the AFT entry. Note that all next-hops that are
specified are assumed to be active next-hops and therefore
eligible (and selected) to be installed in the FIB, and hence
used for packet forwarding.
    """
    return self.__weight
      
  def _set_weight(self, v, load=False):
    """
    Setter method for weight, mapped from YANG variable /network_instances/network_instance/afts/aft/entries/entry/next_hops/next_hop/state/weight (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_weight is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_weight() directly.

    YANG Description: The weight of the next-hop. Traffic is balanced according to
the ratio described by the relative weights of the next hops
that exist for the AFT entry. Note that all next-hops that are
specified are assumed to be active next-hops and therefore
eligible (and selected) to be installed in the FIB, and hence
used for packet forwarding.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """weight must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)""",
        })

    self.__weight = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_weight(self):
    self.__weight = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)


  def _get_ip_address(self):
    """
    Getter method for ip_address, mapped from YANG variable /network_instances/network_instance/afts/aft/entries/entry/next_hops/next_hop/state/ip_address (inet:ip-address-no-zone)

    YANG Description: The IP address of the next-hop system.
    """
    return self.__ip_address
      
  def _set_ip_address(self, v, load=False):
    """
    Setter method for ip_address, mapped from YANG variable /network_instances/network_instance/afts/aft/entries/entry/next_hops/next_hop/state/ip_address (inet:ip-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_address() directly.

    YANG Description: The IP address of the next-hop system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': u'[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': u'[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='inet:ip-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_address must be of a type compatible with inet:ip-address-no-zone""",
          'defined-type': "inet:ip-address-no-zone",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': u'[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': u'[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='inet:ip-address-no-zone', is_config=False)""",
        })

    self.__ip_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_address(self):
    self.__ip_address = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': u'[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': u'[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='inet:ip-address-no-zone', is_config=False)


  def _get_mac_address(self):
    """
    Getter method for mac_address, mapped from YANG variable /network_instances/network_instance/afts/aft/entries/entry/next_hops/next_hop/state/mac_address (yang:mac-address)

    YANG Description: The MAC address of the next-hop if resolved by the local
network instance.
    """
    return self.__mac_address
      
  def _set_mac_address(self, v, load=False):
    """
    Setter method for mac_address, mapped from YANG variable /network_instances/network_instance/afts/aft/entries/entry/next_hops/next_hop/state/mac_address (yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac_address() directly.

    YANG Description: The MAC address of the next-hop if resolved by the local
network instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:mac-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac_address must be of a type compatible with yang:mac-address""",
          'defined-type': "yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:mac-address', is_config=False)""",
        })

    self.__mac_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac_address(self):
    self.__mac_address = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:mac-address', is_config=False)


  def _get_popped_mpls_label_stack(self):
    """
    Getter method for popped_mpls_label_stack, mapped from YANG variable /network_instances/network_instance/afts/aft/entries/entry/next_hops/next_hop/state/popped_mpls_label_stack (oc-mplst:mpls-label)

    YANG Description: The MPLS label stack to be popped from the packet when
switched by the system. The stack is encoding as a leaf-list
whereby the other of the entries is such that the first entry
is the label lowest down the label stack to be popped.

If the local system pops the outer-most label 400, then the
value of this list is [400,]. If the local system removes two
labels, the outer-most being 500, and the second of which is
500, then the value of the list is [500, 400].

A swap operation is reflected by entries in the
popped-mpls-label-stack and pushed-mpls-label-stack nodes.
    """
    return self.__popped_mpls_label_stack
      
  def _set_popped_mpls_label_stack(self, v, load=False):
    """
    Setter method for popped_mpls_label_stack, mapped from YANG variable /network_instances/network_instance/afts/aft/entries/entry/next_hops/next_hop/state/popped_mpls_label_stack (oc-mplst:mpls-label)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_popped_mpls_label_stack is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_popped_mpls_label_stack() directly.

    YANG Description: The MPLS label stack to be popped from the packet when
switched by the system. The stack is encoding as a leaf-list
whereby the other of the entries is such that the first entry
is the label lowest down the label stack to be popped.

If the local system pops the outer-most label 400, then the
value of this list is [400,]. If the local system removes two
labels, the outer-most being 500, and the second of which is
500, then the value of the list is [500, 400].

A swap operation is reflected by entries in the
popped-mpls-label-stack and pushed-mpls-label-stack nodes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=TypedListType(allowed_type=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'16..1048575']}),RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'NO_LABEL': {}, u'IPV6_EXPLICIT_NULL': {'value': 2}, u'ENTROPY_LABEL_INDICATOR': {'value': 7}, u'IPV4_EXPLICIT_NULL': {'value': 0}, u'ROUTER_ALERT': {'value': 1}, u'IMPLICIT_NULL': {'value': 3}},),]), is_leaf=False, yang_name="popped-mpls-label-stack", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-mplst:mpls-label', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """popped_mpls_label_stack must be of a type compatible with oc-mplst:mpls-label""",
          'defined-type': "oc-mplst:mpls-label",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'16..1048575']}),RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'NO_LABEL': {}, u'IPV6_EXPLICIT_NULL': {'value': 2}, u'ENTROPY_LABEL_INDICATOR': {'value': 7}, u'IPV4_EXPLICIT_NULL': {'value': 0}, u'ROUTER_ALERT': {'value': 1}, u'IMPLICIT_NULL': {'value': 3}},),]), is_leaf=False, yang_name="popped-mpls-label-stack", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-mplst:mpls-label', is_config=False)""",
        })

    self.__popped_mpls_label_stack = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_popped_mpls_label_stack(self):
    self.__popped_mpls_label_stack = YANGDynClass(base=TypedListType(allowed_type=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'16..1048575']}),RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'NO_LABEL': {}, u'IPV6_EXPLICIT_NULL': {'value': 2}, u'ENTROPY_LABEL_INDICATOR': {'value': 7}, u'IPV4_EXPLICIT_NULL': {'value': 0}, u'ROUTER_ALERT': {'value': 1}, u'IMPLICIT_NULL': {'value': 3}},),]), is_leaf=False, yang_name="popped-mpls-label-stack", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-mplst:mpls-label', is_config=False)


  def _get_pushed_mpls_label_stack(self):
    """
    Getter method for pushed_mpls_label_stack, mapped from YANG variable /network_instances/network_instance/afts/aft/entries/entry/next_hops/next_hop/state/pushed_mpls_label_stack (oc-mplst:mpls-label)

    YANG Description: The MPLS label stack imposed when forwarding packets to the
next-hop
- the stack is encoded as a leaf list whereby the order of the
 entries is such that the first entry in the list is the
 label at the bottom of the stack to be pushed.

To this end, a packet which is to forwarded to a device using
a service label of 42, and a transport label of 8072 will be
represented with a label stack list of [42, 8072].

The MPLS label stack list is ordered by the user, such that no
system re-ordering of leaves is permitted by the system.

A swap operation is reflected by entries in the
popped-mpls-label-stack and pushed-mpls-label-stack nodes.
    """
    return self.__pushed_mpls_label_stack
      
  def _set_pushed_mpls_label_stack(self, v, load=False):
    """
    Setter method for pushed_mpls_label_stack, mapped from YANG variable /network_instances/network_instance/afts/aft/entries/entry/next_hops/next_hop/state/pushed_mpls_label_stack (oc-mplst:mpls-label)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pushed_mpls_label_stack is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pushed_mpls_label_stack() directly.

    YANG Description: The MPLS label stack imposed when forwarding packets to the
next-hop
- the stack is encoded as a leaf list whereby the order of the
 entries is such that the first entry in the list is the
 label at the bottom of the stack to be pushed.

To this end, a packet which is to forwarded to a device using
a service label of 42, and a transport label of 8072 will be
represented with a label stack list of [42, 8072].

The MPLS label stack list is ordered by the user, such that no
system re-ordering of leaves is permitted by the system.

A swap operation is reflected by entries in the
popped-mpls-label-stack and pushed-mpls-label-stack nodes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=TypedListType(allowed_type=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'16..1048575']}),RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'NO_LABEL': {}, u'IPV6_EXPLICIT_NULL': {'value': 2}, u'ENTROPY_LABEL_INDICATOR': {'value': 7}, u'IPV4_EXPLICIT_NULL': {'value': 0}, u'ROUTER_ALERT': {'value': 1}, u'IMPLICIT_NULL': {'value': 3}},),]), is_leaf=False, yang_name="pushed-mpls-label-stack", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-mplst:mpls-label', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pushed_mpls_label_stack must be of a type compatible with oc-mplst:mpls-label""",
          'defined-type': "oc-mplst:mpls-label",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'16..1048575']}),RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'NO_LABEL': {}, u'IPV6_EXPLICIT_NULL': {'value': 2}, u'ENTROPY_LABEL_INDICATOR': {'value': 7}, u'IPV4_EXPLICIT_NULL': {'value': 0}, u'ROUTER_ALERT': {'value': 1}, u'IMPLICIT_NULL': {'value': 3}},),]), is_leaf=False, yang_name="pushed-mpls-label-stack", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-mplst:mpls-label', is_config=False)""",
        })

    self.__pushed_mpls_label_stack = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pushed_mpls_label_stack(self):
    self.__pushed_mpls_label_stack = YANGDynClass(base=TypedListType(allowed_type=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'16..1048575']}),RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'NO_LABEL': {}, u'IPV6_EXPLICIT_NULL': {'value': 2}, u'ENTROPY_LABEL_INDICATOR': {'value': 7}, u'IPV4_EXPLICIT_NULL': {'value': 0}, u'ROUTER_ALERT': {'value': 1}, u'IMPLICIT_NULL': {'value': 3}},),]), is_leaf=False, yang_name="pushed-mpls-label-stack", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-mplst:mpls-label', is_config=False)


  def _get_decapsulate_header(self):
    """
    Getter method for decapsulate_header, mapped from YANG variable /network_instances/network_instance/afts/aft/entries/entry/next_hops/next_hop/state/decapsulate_header (oc-aftt:encapsulation-header-type)

    YANG Description: When forwarding a packet to the specified next-hop, the local
system performs a decapsulation of the packet - removing the
specified header type. In the case that no next-hop is
specified, the packet header is removed, and a subsequent
forwarding lookup is performed on the packet encapsulated
within the header, matched within the relevant AFT within the
specified network-instance.
    """
    return self.__decapsulate_header
      
  def _set_decapsulate_header(self, v, load=False):
    """
    Setter method for decapsulate_header, mapped from YANG variable /network_instances/network_instance/afts/aft/entries/entry/next_hops/next_hop/state/decapsulate_header (oc-aftt:encapsulation-header-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_decapsulate_header is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_decapsulate_header() directly.

    YANG Description: When forwarding a packet to the specified next-hop, the local
system performs a decapsulation of the packet - removing the
specified header type. In the case that no next-hop is
specified, the packet header is removed, and a subsequent
forwarding lookup is performed on the packet encapsulated
within the header, matched within the relevant AFT within the
specified network-instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'GRE': {}, u'MPLS': {}, u'IPV4': {}, u'IPV6': {}},), is_leaf=True, yang_name="decapsulate-header", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-aftt:encapsulation-header-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """decapsulate_header must be of a type compatible with oc-aftt:encapsulation-header-type""",
          'defined-type': "oc-aftt:encapsulation-header-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'GRE': {}, u'MPLS': {}, u'IPV4': {}, u'IPV6': {}},), is_leaf=True, yang_name="decapsulate-header", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-aftt:encapsulation-header-type', is_config=False)""",
        })

    self.__decapsulate_header = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_decapsulate_header(self):
    self.__decapsulate_header = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'GRE': {}, u'MPLS': {}, u'IPV4': {}, u'IPV6': {}},), is_leaf=True, yang_name="decapsulate-header", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-aftt:encapsulation-header-type', is_config=False)


  def _get_encapsulate_header(self):
    """
    Getter method for encapsulate_header, mapped from YANG variable /network_instances/network_instance/afts/aft/entries/entry/next_hops/next_hop/state/encapsulate_header (oc-aftt:encapsulation-header-type)

    YANG Description: When forwarding a packet to the specified next-hop the local
system performs an encapsulation of the packet - adding the
specified header type.
    """
    return self.__encapsulate_header
      
  def _set_encapsulate_header(self, v, load=False):
    """
    Setter method for encapsulate_header, mapped from YANG variable /network_instances/network_instance/afts/aft/entries/entry/next_hops/next_hop/state/encapsulate_header (oc-aftt:encapsulation-header-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_encapsulate_header is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_encapsulate_header() directly.

    YANG Description: When forwarding a packet to the specified next-hop the local
system performs an encapsulation of the packet - adding the
specified header type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'GRE': {}, u'MPLS': {}, u'IPV4': {}, u'IPV6': {}},), is_leaf=True, yang_name="encapsulate-header", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-aftt:encapsulation-header-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """encapsulate_header must be of a type compatible with oc-aftt:encapsulation-header-type""",
          'defined-type': "oc-aftt:encapsulation-header-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'GRE': {}, u'MPLS': {}, u'IPV4': {}, u'IPV6': {}},), is_leaf=True, yang_name="encapsulate-header", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-aftt:encapsulation-header-type', is_config=False)""",
        })

    self.__encapsulate_header = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_encapsulate_header(self):
    self.__encapsulate_header = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'GRE': {}, u'MPLS': {}, u'IPV4': {}, u'IPV6': {}},), is_leaf=True, yang_name="encapsulate-header", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-aftt:encapsulation-header-type', is_config=False)


  def _get_origin_protocol(self):
    """
    Getter method for origin_protocol, mapped from YANG variable /network_instances/network_instance/afts/aft/entries/entry/next_hops/next_hop/state/origin_protocol (identityref)

    YANG Description: The protocol from which the AFT entry was learned.
    """
    return self.__origin_protocol
      
  def _set_origin_protocol(self, v, load=False):
    """
    Setter method for origin_protocol, mapped from YANG variable /network_instances/network_instance/afts/aft/entries/entry/next_hops/next_hop/state/origin_protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_origin_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_origin_protocol() directly.

    YANG Description: The protocol from which the AFT entry was learned.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-pt:ISIS': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:ISIS': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'ISIS': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'DIRECTLY_CONNECTED': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:OSPF': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:OSPF3': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:STATIC': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:DIRECTLY_CONNECTED': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:BGP': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:LOCAL_AGGREGATE': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'BGP': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:STATIC': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'LOCAL_AGGREGATE': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:OSPF3': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'STATIC': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:BGP': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:LOCAL_AGGREGATE': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'OSPF': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:OSPF': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'OSPF3': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:DIRECTLY_CONNECTED': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}},), is_leaf=True, yang_name="origin-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """origin_protocol must be of a type compatible with identityref""",
          'defined-type': "openconfig-network-instance:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-pt:ISIS': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:ISIS': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'ISIS': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'DIRECTLY_CONNECTED': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:OSPF': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:OSPF3': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:STATIC': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:DIRECTLY_CONNECTED': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:BGP': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:LOCAL_AGGREGATE': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'BGP': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:STATIC': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'LOCAL_AGGREGATE': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:OSPF3': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'STATIC': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:BGP': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:LOCAL_AGGREGATE': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'OSPF': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:OSPF': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'OSPF3': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:DIRECTLY_CONNECTED': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}},), is_leaf=True, yang_name="origin-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=False)""",
        })

    self.__origin_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_origin_protocol(self):
    self.__origin_protocol = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-pt:ISIS': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:ISIS': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'ISIS': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'DIRECTLY_CONNECTED': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:OSPF': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:OSPF3': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:STATIC': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:DIRECTLY_CONNECTED': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:BGP': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:LOCAL_AGGREGATE': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'BGP': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:STATIC': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'LOCAL_AGGREGATE': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:OSPF3': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'STATIC': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:BGP': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:LOCAL_AGGREGATE': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'OSPF': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pt:OSPF': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'OSPF3': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}, u'oc-pol-types:DIRECTLY_CONNECTED': {'@namespace': u'http://openconfig.net/yang/policy-types', '@module': u'openconfig-policy-types'}},), is_leaf=True, yang_name="origin-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=False)

  index = __builtin__.property(_get_index)
  weight = __builtin__.property(_get_weight)
  ip_address = __builtin__.property(_get_ip_address)
  mac_address = __builtin__.property(_get_mac_address)
  popped_mpls_label_stack = __builtin__.property(_get_popped_mpls_label_stack)
  pushed_mpls_label_stack = __builtin__.property(_get_pushed_mpls_label_stack)
  decapsulate_header = __builtin__.property(_get_decapsulate_header)
  encapsulate_header = __builtin__.property(_get_encapsulate_header)
  origin_protocol = __builtin__.property(_get_origin_protocol)


  _pyangbind_elements = {'index': index, 'weight': weight, 'ip_address': ip_address, 'mac_address': mac_address, 'popped_mpls_label_stack': popped_mpls_label_stack, 'pushed_mpls_label_stack': pushed_mpls_label_stack, 'decapsulate_header': decapsulate_header, 'encapsulate_header': encapsulate_header, 'origin_protocol': origin_protocol, }


