
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance - based on the path /network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The container defines a list of system counters for the IS.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__corrupted_lsps','__database_overloads','__manual_address_drop_from_areas','__exceed_max_seq_nums','__seq_num_skips','__own_lsp_purges','__id_len_mismatch','__part_changes','__max_area_address_mismatches','__auth_fails','__spf_runs','__auth_type_fails','__lsp_errors',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__own_lsp_purges = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="own-lsp-purges", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    self.__auth_fails = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auth-fails", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    self.__database_overloads = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="database-overloads", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    self.__corrupted_lsps = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="corrupted-lsps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    self.__id_len_mismatch = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id-len-mismatch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    self.__exceed_max_seq_nums = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="exceed-max-seq-nums", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    self.__lsp_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lsp-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    self.__manual_address_drop_from_areas = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="manual-address-drop-from-areas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    self.__spf_runs = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="spf-runs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    self.__auth_type_fails = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auth-type-fails", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    self.__seq_num_skips = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="seq-num-skips", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    self.__part_changes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="part-changes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    self.__max_area_address_mismatches = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-area-address-mismatches", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'network-instances', u'network-instance', u'protocols', u'protocol', u'isis', u'levels', u'level', u'system-level-counters', u'state']

  def _get_corrupted_lsps(self):
    """
    Getter method for corrupted_lsps, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/corrupted_lsps (yang:counter32)

    YANG Description: Number of corrupted in-memory LSPs detected. LSPs received from the
wire with a bad checksum are silently dropped and not counted. LSPs
received from the wire with parse errors are counted by lsp-errors. MIB
Entry: SysCorrLSPs.
    """
    return self.__corrupted_lsps
      
  def _set_corrupted_lsps(self, v, load=False):
    """
    Setter method for corrupted_lsps, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/corrupted_lsps (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_corrupted_lsps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_corrupted_lsps() directly.

    YANG Description: Number of corrupted in-memory LSPs detected. LSPs received from the
wire with a bad checksum are silently dropped and not counted. LSPs
received from the wire with parse errors are counted by lsp-errors. MIB
Entry: SysCorrLSPs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="corrupted-lsps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """corrupted_lsps must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="corrupted-lsps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)""",
        })

    self.__corrupted_lsps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_corrupted_lsps(self):
    self.__corrupted_lsps = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="corrupted-lsps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)


  def _get_database_overloads(self):
    """
    Getter method for database_overloads, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/database_overloads (yang:counter32)

    YANG Description: Number of times the database has become
overloaded.
MIB entry: SysLSPL(Level)DbaseOloads.
    """
    return self.__database_overloads
      
  def _set_database_overloads(self, v, load=False):
    """
    Setter method for database_overloads, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/database_overloads (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_database_overloads is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_database_overloads() directly.

    YANG Description: Number of times the database has become
overloaded.
MIB entry: SysLSPL(Level)DbaseOloads.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="database-overloads", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """database_overloads must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="database-overloads", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)""",
        })

    self.__database_overloads = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_database_overloads(self):
    self.__database_overloads = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="database-overloads", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)


  def _get_manual_address_drop_from_areas(self):
    """
    Getter method for manual_address_drop_from_areas, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/manual_address_drop_from_areas (yang:counter32)

    YANG Description: Number of times a manual address has been dropped from area.
MIB Entry: SysManAddrDropFromAreas.
    """
    return self.__manual_address_drop_from_areas
      
  def _set_manual_address_drop_from_areas(self, v, load=False):
    """
    Setter method for manual_address_drop_from_areas, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/manual_address_drop_from_areas (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_manual_address_drop_from_areas is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_manual_address_drop_from_areas() directly.

    YANG Description: Number of times a manual address has been dropped from area.
MIB Entry: SysManAddrDropFromAreas.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="manual-address-drop-from-areas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """manual_address_drop_from_areas must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="manual-address-drop-from-areas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)""",
        })

    self.__manual_address_drop_from_areas = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_manual_address_drop_from_areas(self):
    self.__manual_address_drop_from_areas = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="manual-address-drop-from-areas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)


  def _get_exceed_max_seq_nums(self):
    """
    Getter method for exceed_max_seq_nums, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/exceed_max_seq_nums (yang:counter32)

    YANG Description: The number of times the system has attempted to exceed the maximum
sequence number. MIB Entry: SysAttmptToExMaxSeqNums.
    """
    return self.__exceed_max_seq_nums
      
  def _set_exceed_max_seq_nums(self, v, load=False):
    """
    Setter method for exceed_max_seq_nums, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/exceed_max_seq_nums (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_exceed_max_seq_nums is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_exceed_max_seq_nums() directly.

    YANG Description: The number of times the system has attempted to exceed the maximum
sequence number. MIB Entry: SysAttmptToExMaxSeqNums.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="exceed-max-seq-nums", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """exceed_max_seq_nums must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="exceed-max-seq-nums", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)""",
        })

    self.__exceed_max_seq_nums = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_exceed_max_seq_nums(self):
    self.__exceed_max_seq_nums = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="exceed-max-seq-nums", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)


  def _get_seq_num_skips(self):
    """
    Getter method for seq_num_skips, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/seq_num_skips (yang:counter32)

    YANG Description: Number of times a sequence number skip has occurred. MIB Entry:
SysSeqNumSkips.
    """
    return self.__seq_num_skips
      
  def _set_seq_num_skips(self, v, load=False):
    """
    Setter method for seq_num_skips, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/seq_num_skips (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_seq_num_skips is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_seq_num_skips() directly.

    YANG Description: Number of times a sequence number skip has occurred. MIB Entry:
SysSeqNumSkips.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="seq-num-skips", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """seq_num_skips must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="seq-num-skips", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)""",
        })

    self.__seq_num_skips = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_seq_num_skips(self):
    self.__seq_num_skips = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="seq-num-skips", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)


  def _get_own_lsp_purges(self):
    """
    Getter method for own_lsp_purges, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/own_lsp_purges (yang:counter32)

    YANG Description: Number of times a zero-aged copy of the system's
own LSP is received from some other node.
MIB Entry: isisSysOwnLSPPurges.
    """
    return self.__own_lsp_purges
      
  def _set_own_lsp_purges(self, v, load=False):
    """
    Setter method for own_lsp_purges, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/own_lsp_purges (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_own_lsp_purges is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_own_lsp_purges() directly.

    YANG Description: Number of times a zero-aged copy of the system's
own LSP is received from some other node.
MIB Entry: isisSysOwnLSPPurges.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="own-lsp-purges", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """own_lsp_purges must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="own-lsp-purges", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)""",
        })

    self.__own_lsp_purges = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_own_lsp_purges(self):
    self.__own_lsp_purges = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="own-lsp-purges", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)


  def _get_id_len_mismatch(self):
    """
    Getter method for id_len_mismatch, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/id_len_mismatch (yang:counter32)

    YANG Description: Number of times a PDU is received with a different value for ID field
length from that of the receiving system. MIB Entry:
isisSysIDFieldLenMismatches.
    """
    return self.__id_len_mismatch
      
  def _set_id_len_mismatch(self, v, load=False):
    """
    Setter method for id_len_mismatch, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/id_len_mismatch (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id_len_mismatch is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id_len_mismatch() directly.

    YANG Description: Number of times a PDU is received with a different value for ID field
length from that of the receiving system. MIB Entry:
isisSysIDFieldLenMismatches.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id-len-mismatch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id_len_mismatch must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id-len-mismatch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)""",
        })

    self.__id_len_mismatch = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id_len_mismatch(self):
    self.__id_len_mismatch = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id-len-mismatch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)


  def _get_part_changes(self):
    """
    Getter method for part_changes, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/part_changes (yang:counter32)

    YANG Description: The number of partition changes detected. MIB Entry: SysPartChanges.
    """
    return self.__part_changes
      
  def _set_part_changes(self, v, load=False):
    """
    Setter method for part_changes, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/part_changes (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_part_changes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_part_changes() directly.

    YANG Description: The number of partition changes detected. MIB Entry: SysPartChanges.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="part-changes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """part_changes must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="part-changes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)""",
        })

    self.__part_changes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_part_changes(self):
    self.__part_changes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="part-changes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)


  def _get_max_area_address_mismatches(self):
    """
    Getter method for max_area_address_mismatches, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/max_area_address_mismatches (yang:counter32)

    YANG Description: Number of times a PDU is received with a different value for
MaximumAreaAddresses from that of the receiving system. MIB Entry:
SysMaxAreaAddrMismatches.
    """
    return self.__max_area_address_mismatches
      
  def _set_max_area_address_mismatches(self, v, load=False):
    """
    Setter method for max_area_address_mismatches, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/max_area_address_mismatches (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_area_address_mismatches is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_area_address_mismatches() directly.

    YANG Description: Number of times a PDU is received with a different value for
MaximumAreaAddresses from that of the receiving system. MIB Entry:
SysMaxAreaAddrMismatches.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-area-address-mismatches", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_area_address_mismatches must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-area-address-mismatches", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)""",
        })

    self.__max_area_address_mismatches = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_area_address_mismatches(self):
    self.__max_area_address_mismatches = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-area-address-mismatches", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)


  def _get_auth_fails(self):
    """
    Getter method for auth_fails, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/auth_fails (yang:counter32)

    YANG Description: The number of authentication key failures.
MIB Entry: SysAuthFails.
    """
    return self.__auth_fails
      
  def _set_auth_fails(self, v, load=False):
    """
    Setter method for auth_fails, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/auth_fails (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auth_fails is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auth_fails() directly.

    YANG Description: The number of authentication key failures.
MIB Entry: SysAuthFails.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auth-fails", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auth_fails must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auth-fails", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)""",
        })

    self.__auth_fails = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auth_fails(self):
    self.__auth_fails = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auth-fails", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)


  def _get_spf_runs(self):
    """
    Getter method for spf_runs, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/spf_runs (yang:counter32)

    YANG Description: The number of times SPF was ran at this level.
    """
    return self.__spf_runs
      
  def _set_spf_runs(self, v, load=False):
    """
    Setter method for spf_runs, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/spf_runs (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_spf_runs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_spf_runs() directly.

    YANG Description: The number of times SPF was ran at this level.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="spf-runs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """spf_runs must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="spf-runs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)""",
        })

    self.__spf_runs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_spf_runs(self):
    self.__spf_runs = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="spf-runs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)


  def _get_auth_type_fails(self):
    """
    Getter method for auth_type_fails, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/auth_type_fails (yang:counter32)

    YANG Description: The number of authentication type mismatches.
    """
    return self.__auth_type_fails
      
  def _set_auth_type_fails(self, v, load=False):
    """
    Setter method for auth_type_fails, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/auth_type_fails (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auth_type_fails is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auth_type_fails() directly.

    YANG Description: The number of authentication type mismatches.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auth-type-fails", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auth_type_fails must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auth-type-fails", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)""",
        })

    self.__auth_type_fails = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auth_type_fails(self):
    self.__auth_type_fails = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auth-type-fails", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)


  def _get_lsp_errors(self):
    """
    Getter method for lsp_errors, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/lsp_errors (yang:counter32)

    YANG Description: The number of received LSPs with errors.
    """
    return self.__lsp_errors
      
  def _set_lsp_errors(self, v, load=False):
    """
    Setter method for lsp_errors, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/lsp_errors (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsp_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsp_errors() directly.

    YANG Description: The number of received LSPs with errors.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lsp-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsp_errors must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lsp-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)""",
        })

    self.__lsp_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsp_errors(self):
    self.__lsp_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lsp-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)

  corrupted_lsps = __builtin__.property(_get_corrupted_lsps)
  database_overloads = __builtin__.property(_get_database_overloads)
  manual_address_drop_from_areas = __builtin__.property(_get_manual_address_drop_from_areas)
  exceed_max_seq_nums = __builtin__.property(_get_exceed_max_seq_nums)
  seq_num_skips = __builtin__.property(_get_seq_num_skips)
  own_lsp_purges = __builtin__.property(_get_own_lsp_purges)
  id_len_mismatch = __builtin__.property(_get_id_len_mismatch)
  part_changes = __builtin__.property(_get_part_changes)
  max_area_address_mismatches = __builtin__.property(_get_max_area_address_mismatches)
  auth_fails = __builtin__.property(_get_auth_fails)
  spf_runs = __builtin__.property(_get_spf_runs)
  auth_type_fails = __builtin__.property(_get_auth_type_fails)
  lsp_errors = __builtin__.property(_get_lsp_errors)


  _pyangbind_elements = {'corrupted_lsps': corrupted_lsps, 'database_overloads': database_overloads, 'manual_address_drop_from_areas': manual_address_drop_from_areas, 'exceed_max_seq_nums': exceed_max_seq_nums, 'seq_num_skips': seq_num_skips, 'own_lsp_purges': own_lsp_purges, 'id_len_mismatch': id_len_mismatch, 'part_changes': part_changes, 'max_area_address_mismatches': max_area_address_mismatches, 'auth_fails': auth_fails, 'spf_runs': spf_runs, 'auth_type_fails': auth_type_fails, 'lsp_errors': lsp_errors, }


class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance-l2 - based on the path /network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The container defines a list of system counters for the IS.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__corrupted_lsps','__database_overloads','__manual_address_drop_from_areas','__exceed_max_seq_nums','__seq_num_skips','__own_lsp_purges','__id_len_mismatch','__part_changes','__max_area_address_mismatches','__auth_fails','__spf_runs','__auth_type_fails','__lsp_errors',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__own_lsp_purges = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="own-lsp-purges", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    self.__auth_fails = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auth-fails", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    self.__database_overloads = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="database-overloads", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    self.__corrupted_lsps = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="corrupted-lsps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    self.__id_len_mismatch = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id-len-mismatch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    self.__exceed_max_seq_nums = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="exceed-max-seq-nums", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    self.__lsp_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lsp-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    self.__manual_address_drop_from_areas = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="manual-address-drop-from-areas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    self.__spf_runs = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="spf-runs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    self.__auth_type_fails = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auth-type-fails", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    self.__seq_num_skips = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="seq-num-skips", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    self.__part_changes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="part-changes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    self.__max_area_address_mismatches = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-area-address-mismatches", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'network-instances', u'network-instance', u'protocols', u'protocol', u'isis', u'levels', u'level', u'system-level-counters', u'state']

  def _get_corrupted_lsps(self):
    """
    Getter method for corrupted_lsps, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/corrupted_lsps (yang:counter32)

    YANG Description: Number of corrupted in-memory LSPs detected. LSPs received from the
wire with a bad checksum are silently dropped and not counted. LSPs
received from the wire with parse errors are counted by lsp-errors. MIB
Entry: SysCorrLSPs.
    """
    return self.__corrupted_lsps
      
  def _set_corrupted_lsps(self, v, load=False):
    """
    Setter method for corrupted_lsps, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/corrupted_lsps (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_corrupted_lsps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_corrupted_lsps() directly.

    YANG Description: Number of corrupted in-memory LSPs detected. LSPs received from the
wire with a bad checksum are silently dropped and not counted. LSPs
received from the wire with parse errors are counted by lsp-errors. MIB
Entry: SysCorrLSPs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="corrupted-lsps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """corrupted_lsps must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="corrupted-lsps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)""",
        })

    self.__corrupted_lsps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_corrupted_lsps(self):
    self.__corrupted_lsps = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="corrupted-lsps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)


  def _get_database_overloads(self):
    """
    Getter method for database_overloads, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/database_overloads (yang:counter32)

    YANG Description: Number of times the database has become
overloaded.
MIB entry: SysLSPL(Level)DbaseOloads.
    """
    return self.__database_overloads
      
  def _set_database_overloads(self, v, load=False):
    """
    Setter method for database_overloads, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/database_overloads (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_database_overloads is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_database_overloads() directly.

    YANG Description: Number of times the database has become
overloaded.
MIB entry: SysLSPL(Level)DbaseOloads.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="database-overloads", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """database_overloads must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="database-overloads", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)""",
        })

    self.__database_overloads = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_database_overloads(self):
    self.__database_overloads = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="database-overloads", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)


  def _get_manual_address_drop_from_areas(self):
    """
    Getter method for manual_address_drop_from_areas, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/manual_address_drop_from_areas (yang:counter32)

    YANG Description: Number of times a manual address has been dropped from area.
MIB Entry: SysManAddrDropFromAreas.
    """
    return self.__manual_address_drop_from_areas
      
  def _set_manual_address_drop_from_areas(self, v, load=False):
    """
    Setter method for manual_address_drop_from_areas, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/manual_address_drop_from_areas (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_manual_address_drop_from_areas is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_manual_address_drop_from_areas() directly.

    YANG Description: Number of times a manual address has been dropped from area.
MIB Entry: SysManAddrDropFromAreas.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="manual-address-drop-from-areas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """manual_address_drop_from_areas must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="manual-address-drop-from-areas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)""",
        })

    self.__manual_address_drop_from_areas = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_manual_address_drop_from_areas(self):
    self.__manual_address_drop_from_areas = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="manual-address-drop-from-areas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)


  def _get_exceed_max_seq_nums(self):
    """
    Getter method for exceed_max_seq_nums, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/exceed_max_seq_nums (yang:counter32)

    YANG Description: The number of times the system has attempted to exceed the maximum
sequence number. MIB Entry: SysAttmptToExMaxSeqNums.
    """
    return self.__exceed_max_seq_nums
      
  def _set_exceed_max_seq_nums(self, v, load=False):
    """
    Setter method for exceed_max_seq_nums, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/exceed_max_seq_nums (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_exceed_max_seq_nums is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_exceed_max_seq_nums() directly.

    YANG Description: The number of times the system has attempted to exceed the maximum
sequence number. MIB Entry: SysAttmptToExMaxSeqNums.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="exceed-max-seq-nums", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """exceed_max_seq_nums must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="exceed-max-seq-nums", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)""",
        })

    self.__exceed_max_seq_nums = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_exceed_max_seq_nums(self):
    self.__exceed_max_seq_nums = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="exceed-max-seq-nums", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)


  def _get_seq_num_skips(self):
    """
    Getter method for seq_num_skips, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/seq_num_skips (yang:counter32)

    YANG Description: Number of times a sequence number skip has occurred. MIB Entry:
SysSeqNumSkips.
    """
    return self.__seq_num_skips
      
  def _set_seq_num_skips(self, v, load=False):
    """
    Setter method for seq_num_skips, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/seq_num_skips (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_seq_num_skips is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_seq_num_skips() directly.

    YANG Description: Number of times a sequence number skip has occurred. MIB Entry:
SysSeqNumSkips.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="seq-num-skips", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """seq_num_skips must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="seq-num-skips", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)""",
        })

    self.__seq_num_skips = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_seq_num_skips(self):
    self.__seq_num_skips = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="seq-num-skips", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)


  def _get_own_lsp_purges(self):
    """
    Getter method for own_lsp_purges, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/own_lsp_purges (yang:counter32)

    YANG Description: Number of times a zero-aged copy of the system's
own LSP is received from some other node.
MIB Entry: isisSysOwnLSPPurges.
    """
    return self.__own_lsp_purges
      
  def _set_own_lsp_purges(self, v, load=False):
    """
    Setter method for own_lsp_purges, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/own_lsp_purges (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_own_lsp_purges is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_own_lsp_purges() directly.

    YANG Description: Number of times a zero-aged copy of the system's
own LSP is received from some other node.
MIB Entry: isisSysOwnLSPPurges.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="own-lsp-purges", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """own_lsp_purges must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="own-lsp-purges", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)""",
        })

    self.__own_lsp_purges = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_own_lsp_purges(self):
    self.__own_lsp_purges = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="own-lsp-purges", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)


  def _get_id_len_mismatch(self):
    """
    Getter method for id_len_mismatch, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/id_len_mismatch (yang:counter32)

    YANG Description: Number of times a PDU is received with a different value for ID field
length from that of the receiving system. MIB Entry:
isisSysIDFieldLenMismatches.
    """
    return self.__id_len_mismatch
      
  def _set_id_len_mismatch(self, v, load=False):
    """
    Setter method for id_len_mismatch, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/id_len_mismatch (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id_len_mismatch is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id_len_mismatch() directly.

    YANG Description: Number of times a PDU is received with a different value for ID field
length from that of the receiving system. MIB Entry:
isisSysIDFieldLenMismatches.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id-len-mismatch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id_len_mismatch must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id-len-mismatch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)""",
        })

    self.__id_len_mismatch = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id_len_mismatch(self):
    self.__id_len_mismatch = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id-len-mismatch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)


  def _get_part_changes(self):
    """
    Getter method for part_changes, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/part_changes (yang:counter32)

    YANG Description: The number of partition changes detected. MIB Entry: SysPartChanges.
    """
    return self.__part_changes
      
  def _set_part_changes(self, v, load=False):
    """
    Setter method for part_changes, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/part_changes (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_part_changes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_part_changes() directly.

    YANG Description: The number of partition changes detected. MIB Entry: SysPartChanges.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="part-changes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """part_changes must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="part-changes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)""",
        })

    self.__part_changes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_part_changes(self):
    self.__part_changes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="part-changes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)


  def _get_max_area_address_mismatches(self):
    """
    Getter method for max_area_address_mismatches, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/max_area_address_mismatches (yang:counter32)

    YANG Description: Number of times a PDU is received with a different value for
MaximumAreaAddresses from that of the receiving system. MIB Entry:
SysMaxAreaAddrMismatches.
    """
    return self.__max_area_address_mismatches
      
  def _set_max_area_address_mismatches(self, v, load=False):
    """
    Setter method for max_area_address_mismatches, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/max_area_address_mismatches (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_area_address_mismatches is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_area_address_mismatches() directly.

    YANG Description: Number of times a PDU is received with a different value for
MaximumAreaAddresses from that of the receiving system. MIB Entry:
SysMaxAreaAddrMismatches.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-area-address-mismatches", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_area_address_mismatches must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-area-address-mismatches", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)""",
        })

    self.__max_area_address_mismatches = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_area_address_mismatches(self):
    self.__max_area_address_mismatches = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-area-address-mismatches", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)


  def _get_auth_fails(self):
    """
    Getter method for auth_fails, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/auth_fails (yang:counter32)

    YANG Description: The number of authentication key failures.
MIB Entry: SysAuthFails.
    """
    return self.__auth_fails
      
  def _set_auth_fails(self, v, load=False):
    """
    Setter method for auth_fails, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/auth_fails (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auth_fails is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auth_fails() directly.

    YANG Description: The number of authentication key failures.
MIB Entry: SysAuthFails.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auth-fails", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auth_fails must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auth-fails", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)""",
        })

    self.__auth_fails = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auth_fails(self):
    self.__auth_fails = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auth-fails", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)


  def _get_spf_runs(self):
    """
    Getter method for spf_runs, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/spf_runs (yang:counter32)

    YANG Description: The number of times SPF was ran at this level.
    """
    return self.__spf_runs
      
  def _set_spf_runs(self, v, load=False):
    """
    Setter method for spf_runs, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/spf_runs (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_spf_runs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_spf_runs() directly.

    YANG Description: The number of times SPF was ran at this level.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="spf-runs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """spf_runs must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="spf-runs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)""",
        })

    self.__spf_runs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_spf_runs(self):
    self.__spf_runs = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="spf-runs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)


  def _get_auth_type_fails(self):
    """
    Getter method for auth_type_fails, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/auth_type_fails (yang:counter32)

    YANG Description: The number of authentication type mismatches.
    """
    return self.__auth_type_fails
      
  def _set_auth_type_fails(self, v, load=False):
    """
    Setter method for auth_type_fails, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/auth_type_fails (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auth_type_fails is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auth_type_fails() directly.

    YANG Description: The number of authentication type mismatches.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auth-type-fails", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auth_type_fails must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auth-type-fails", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)""",
        })

    self.__auth_type_fails = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auth_type_fails(self):
    self.__auth_type_fails = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auth-type-fails", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)


  def _get_lsp_errors(self):
    """
    Getter method for lsp_errors, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/lsp_errors (yang:counter32)

    YANG Description: The number of received LSPs with errors.
    """
    return self.__lsp_errors
      
  def _set_lsp_errors(self, v, load=False):
    """
    Setter method for lsp_errors, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/system_level_counters/state/lsp_errors (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsp_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsp_errors() directly.

    YANG Description: The number of received LSPs with errors.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lsp-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsp_errors must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lsp-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)""",
        })

    self.__lsp_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsp_errors(self):
    self.__lsp_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lsp-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:counter32', is_config=False)

  corrupted_lsps = __builtin__.property(_get_corrupted_lsps)
  database_overloads = __builtin__.property(_get_database_overloads)
  manual_address_drop_from_areas = __builtin__.property(_get_manual_address_drop_from_areas)
  exceed_max_seq_nums = __builtin__.property(_get_exceed_max_seq_nums)
  seq_num_skips = __builtin__.property(_get_seq_num_skips)
  own_lsp_purges = __builtin__.property(_get_own_lsp_purges)
  id_len_mismatch = __builtin__.property(_get_id_len_mismatch)
  part_changes = __builtin__.property(_get_part_changes)
  max_area_address_mismatches = __builtin__.property(_get_max_area_address_mismatches)
  auth_fails = __builtin__.property(_get_auth_fails)
  spf_runs = __builtin__.property(_get_spf_runs)
  auth_type_fails = __builtin__.property(_get_auth_type_fails)
  lsp_errors = __builtin__.property(_get_lsp_errors)


  _pyangbind_elements = {'corrupted_lsps': corrupted_lsps, 'database_overloads': database_overloads, 'manual_address_drop_from_areas': manual_address_drop_from_areas, 'exceed_max_seq_nums': exceed_max_seq_nums, 'seq_num_skips': seq_num_skips, 'own_lsp_purges': own_lsp_purges, 'id_len_mismatch': id_len_mismatch, 'part_changes': part_changes, 'max_area_address_mismatches': max_area_address_mismatches, 'auth_fails': auth_fails, 'spf_runs': spf_runs, 'auth_type_fails': auth_type_fails, 'lsp_errors': lsp_errors, }


