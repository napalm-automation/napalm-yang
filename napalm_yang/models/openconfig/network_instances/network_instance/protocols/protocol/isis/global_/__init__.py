
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import config
import state
import lsp_bit
import reference_bandwidth
import nsr
import graceful_restart
import timers
import transport
import mpls
import igp_shortcuts
import afi_safi
import segment_routing
import inter_level_propagation_policies
class global_(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance - based on the path /network-instances/network-instance/protocols/protocol/isis/global. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This container defines global ISIS configuration and state
information.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__config','__state','__lsp_bit','__reference_bandwidth','__nsr','__graceful_restart','__timers','__transport','__mpls','__igp_shortcuts','__afi_safi','__segment_routing','__inter_level_propagation_policies',)

  _yang_name = 'global'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__inter_level_propagation_policies = YANGDynClass(base=inter_level_propagation_policies.inter_level_propagation_policies, is_container='container', yang_name="inter-level-propagation-policies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__graceful_restart = YANGDynClass(base=graceful_restart.graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__mpls = YANGDynClass(base=mpls.mpls, is_container='container', yang_name="mpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__afi_safi = YANGDynClass(base=afi_safi.afi_safi, is_container='container', yang_name="afi-safi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__reference_bandwidth = YANGDynClass(base=reference_bandwidth.reference_bandwidth, is_container='container', yang_name="reference-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__timers = YANGDynClass(base=timers.timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__transport = YANGDynClass(base=transport.transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__igp_shortcuts = YANGDynClass(base=igp_shortcuts.igp_shortcuts, is_container='container', yang_name="igp-shortcuts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__nsr = YANGDynClass(base=nsr.nsr, is_container='container', yang_name="nsr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__segment_routing = YANGDynClass(base=segment_routing.segment_routing, is_container='container', yang_name="segment-routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__lsp_bit = YANGDynClass(base=lsp_bit.lsp_bit, is_container='container', yang_name="lsp-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'network-instances', u'network-instance', u'protocols', u'protocol', u'isis', u'global']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/config (container)

    YANG Description: This container defines ISIS global configuration router.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: This container defines ISIS global configuration router.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/state (container)

    YANG Description: This container defines state for ISIS global router.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: This container defines state for ISIS global router.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_lsp_bit(self):
    """
    Getter method for lsp_bit, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/lsp_bit (container)

    YANG Description: This container defines ISIS LSP Operational Bits.
    """
    return self.__lsp_bit
      
  def _set_lsp_bit(self, v, load=False):
    """
    Setter method for lsp_bit, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/lsp_bit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsp_bit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsp_bit() directly.

    YANG Description: This container defines ISIS LSP Operational Bits.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=lsp_bit.lsp_bit, is_container='container', yang_name="lsp-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsp_bit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=lsp_bit.lsp_bit, is_container='container', yang_name="lsp-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__lsp_bit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsp_bit(self):
    self.__lsp_bit = YANGDynClass(base=lsp_bit.lsp_bit, is_container='container', yang_name="lsp-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_reference_bandwidth(self):
    """
    Getter method for reference_bandwidth, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/reference_bandwidth (container)

    YANG Description: This container defines ISIS Reference Bandwidth.
    """
    return self.__reference_bandwidth
      
  def _set_reference_bandwidth(self, v, load=False):
    """
    Setter method for reference_bandwidth, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/reference_bandwidth (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reference_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reference_bandwidth() directly.

    YANG Description: This container defines ISIS Reference Bandwidth.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=reference_bandwidth.reference_bandwidth, is_container='container', yang_name="reference-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reference_bandwidth must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=reference_bandwidth.reference_bandwidth, is_container='container', yang_name="reference-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__reference_bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reference_bandwidth(self):
    self.__reference_bandwidth = YANGDynClass(base=reference_bandwidth.reference_bandwidth, is_container='container', yang_name="reference-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_nsr(self):
    """
    Getter method for nsr, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/nsr (container)

    YANG Description: This container defines ISIS Non-Stop Routing.
    """
    return self.__nsr
      
  def _set_nsr(self, v, load=False):
    """
    Setter method for nsr, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/nsr (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nsr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nsr() directly.

    YANG Description: This container defines ISIS Non-Stop Routing.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=nsr.nsr, is_container='container', yang_name="nsr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nsr must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=nsr.nsr, is_container='container', yang_name="nsr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__nsr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nsr(self):
    self.__nsr = YANGDynClass(base=nsr.nsr, is_container='container', yang_name="nsr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_graceful_restart(self):
    """
    Getter method for graceful_restart, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/graceful_restart (container)

    YANG Description: This container defines ISIS Graceful Restart.
    """
    return self.__graceful_restart
      
  def _set_graceful_restart(self, v, load=False):
    """
    Setter method for graceful_restart, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/graceful_restart (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_graceful_restart is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_graceful_restart() directly.

    YANG Description: This container defines ISIS Graceful Restart.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=graceful_restart.graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """graceful_restart must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=graceful_restart.graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__graceful_restart = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_graceful_restart(self):
    self.__graceful_restart = YANGDynClass(base=graceful_restart.graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_timers(self):
    """
    Getter method for timers, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/timers (container)

    YANG Description: This container defines ISIS timers.
    """
    return self.__timers
      
  def _set_timers(self, v, load=False):
    """
    Setter method for timers, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/timers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timers() directly.

    YANG Description: This container defines ISIS timers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=timers.timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=timers.timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__timers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timers(self):
    self.__timers = YANGDynClass(base=timers.timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_transport(self):
    """
    Getter method for transport, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/transport (container)

    YANG Description: This container defines ISIS transport.
    """
    return self.__transport
      
  def _set_transport(self, v, load=False):
    """
    Setter method for transport, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/transport (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transport is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transport() directly.

    YANG Description: This container defines ISIS transport.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=transport.transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transport must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=transport.transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__transport = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transport(self):
    self.__transport = YANGDynClass(base=transport.transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_mpls(self):
    """
    Getter method for mpls, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/mpls (container)

    YANG Description: Configuration and operational state relating to MPLS-related
features in IS-IS
    """
    return self.__mpls
      
  def _set_mpls(self, v, load=False):
    """
    Setter method for mpls, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/mpls (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mpls is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mpls() directly.

    YANG Description: Configuration and operational state relating to MPLS-related
features in IS-IS
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=mpls.mpls, is_container='container', yang_name="mpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mpls must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=mpls.mpls, is_container='container', yang_name="mpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__mpls = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mpls(self):
    self.__mpls = YANGDynClass(base=mpls.mpls, is_container='container', yang_name="mpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_igp_shortcuts(self):
    """
    Getter method for igp_shortcuts, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/igp_shortcuts (container)

    YANG Description: This container defines IGP shortcuts configuration and state
information.
    """
    return self.__igp_shortcuts
      
  def _set_igp_shortcuts(self, v, load=False):
    """
    Setter method for igp_shortcuts, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/igp_shortcuts (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_igp_shortcuts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_igp_shortcuts() directly.

    YANG Description: This container defines IGP shortcuts configuration and state
information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=igp_shortcuts.igp_shortcuts, is_container='container', yang_name="igp-shortcuts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """igp_shortcuts must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=igp_shortcuts.igp_shortcuts, is_container='container', yang_name="igp-shortcuts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__igp_shortcuts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_igp_shortcuts(self):
    self.__igp_shortcuts = YANGDynClass(base=igp_shortcuts.igp_shortcuts, is_container='container', yang_name="igp-shortcuts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_afi_safi(self):
    """
    Getter method for afi_safi, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/afi_safi (container)

    YANG Description: This container defines address-family specific configuration
and state information.
    """
    return self.__afi_safi
      
  def _set_afi_safi(self, v, load=False):
    """
    Setter method for afi_safi, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/afi_safi (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_afi_safi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_afi_safi() directly.

    YANG Description: This container defines address-family specific configuration
and state information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=afi_safi.afi_safi, is_container='container', yang_name="afi-safi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """afi_safi must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=afi_safi.afi_safi, is_container='container', yang_name="afi-safi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__afi_safi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_afi_safi(self):
    self.__afi_safi = YANGDynClass(base=afi_safi.afi_safi, is_container='container', yang_name="afi-safi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_segment_routing(self):
    """
    Getter method for segment_routing, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/segment_routing (container)

    YANG Description: Configuration and operational state relating to segment routing.
    """
    return self.__segment_routing
      
  def _set_segment_routing(self, v, load=False):
    """
    Setter method for segment_routing, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/segment_routing (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_segment_routing is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_segment_routing() directly.

    YANG Description: Configuration and operational state relating to segment routing.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=segment_routing.segment_routing, is_container='container', yang_name="segment-routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """segment_routing must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=segment_routing.segment_routing, is_container='container', yang_name="segment-routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__segment_routing = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_segment_routing(self):
    self.__segment_routing = YANGDynClass(base=segment_routing.segment_routing, is_container='container', yang_name="segment-routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_inter_level_propagation_policies(self):
    """
    Getter method for inter_level_propagation_policies, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/inter_level_propagation_policies (container)

    YANG Description: Policies to propagate prefixes between IS-IS levels.
    """
    return self.__inter_level_propagation_policies
      
  def _set_inter_level_propagation_policies(self, v, load=False):
    """
    Setter method for inter_level_propagation_policies, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/inter_level_propagation_policies (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inter_level_propagation_policies is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inter_level_propagation_policies() directly.

    YANG Description: Policies to propagate prefixes between IS-IS levels.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=inter_level_propagation_policies.inter_level_propagation_policies, is_container='container', yang_name="inter-level-propagation-policies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inter_level_propagation_policies must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=inter_level_propagation_policies.inter_level_propagation_policies, is_container='container', yang_name="inter-level-propagation-policies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__inter_level_propagation_policies = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inter_level_propagation_policies(self):
    self.__inter_level_propagation_policies = YANGDynClass(base=inter_level_propagation_policies.inter_level_propagation_policies, is_container='container', yang_name="inter-level-propagation-policies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  lsp_bit = __builtin__.property(_get_lsp_bit, _set_lsp_bit)
  reference_bandwidth = __builtin__.property(_get_reference_bandwidth, _set_reference_bandwidth)
  nsr = __builtin__.property(_get_nsr, _set_nsr)
  graceful_restart = __builtin__.property(_get_graceful_restart, _set_graceful_restart)
  timers = __builtin__.property(_get_timers, _set_timers)
  transport = __builtin__.property(_get_transport, _set_transport)
  mpls = __builtin__.property(_get_mpls, _set_mpls)
  igp_shortcuts = __builtin__.property(_get_igp_shortcuts, _set_igp_shortcuts)
  afi_safi = __builtin__.property(_get_afi_safi, _set_afi_safi)
  segment_routing = __builtin__.property(_get_segment_routing, _set_segment_routing)
  inter_level_propagation_policies = __builtin__.property(_get_inter_level_propagation_policies, _set_inter_level_propagation_policies)


  _pyangbind_elements = {'config': config, 'state': state, 'lsp_bit': lsp_bit, 'reference_bandwidth': reference_bandwidth, 'nsr': nsr, 'graceful_restart': graceful_restart, 'timers': timers, 'transport': transport, 'mpls': mpls, 'igp_shortcuts': igp_shortcuts, 'afi_safi': afi_safi, 'segment_routing': segment_routing, 'inter_level_propagation_policies': inter_level_propagation_policies, }


import config
import state
import lsp_bit
import reference_bandwidth
import nsr
import graceful_restart
import timers
import transport
import mpls
import igp_shortcuts
import afi_safi
import segment_routing
import inter_level_propagation_policies
class global_(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance-l2 - based on the path /network-instances/network-instance/protocols/protocol/isis/global. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This container defines global ISIS configuration and state
information.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__config','__state','__lsp_bit','__reference_bandwidth','__nsr','__graceful_restart','__timers','__transport','__mpls','__igp_shortcuts','__afi_safi','__segment_routing','__inter_level_propagation_policies',)

  _yang_name = 'global'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__inter_level_propagation_policies = YANGDynClass(base=inter_level_propagation_policies.inter_level_propagation_policies, is_container='container', yang_name="inter-level-propagation-policies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__graceful_restart = YANGDynClass(base=graceful_restart.graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__mpls = YANGDynClass(base=mpls.mpls, is_container='container', yang_name="mpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__afi_safi = YANGDynClass(base=afi_safi.afi_safi, is_container='container', yang_name="afi-safi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__reference_bandwidth = YANGDynClass(base=reference_bandwidth.reference_bandwidth, is_container='container', yang_name="reference-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__timers = YANGDynClass(base=timers.timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__transport = YANGDynClass(base=transport.transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__igp_shortcuts = YANGDynClass(base=igp_shortcuts.igp_shortcuts, is_container='container', yang_name="igp-shortcuts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__nsr = YANGDynClass(base=nsr.nsr, is_container='container', yang_name="nsr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__segment_routing = YANGDynClass(base=segment_routing.segment_routing, is_container='container', yang_name="segment-routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    self.__lsp_bit = YANGDynClass(base=lsp_bit.lsp_bit, is_container='container', yang_name="lsp-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'network-instances', u'network-instance', u'protocols', u'protocol', u'isis', u'global']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/config (container)

    YANG Description: This container defines ISIS global configuration router.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: This container defines ISIS global configuration router.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/state (container)

    YANG Description: This container defines state for ISIS global router.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: This container defines state for ISIS global router.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_lsp_bit(self):
    """
    Getter method for lsp_bit, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/lsp_bit (container)

    YANG Description: This container defines ISIS LSP Operational Bits.
    """
    return self.__lsp_bit
      
  def _set_lsp_bit(self, v, load=False):
    """
    Setter method for lsp_bit, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/lsp_bit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsp_bit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsp_bit() directly.

    YANG Description: This container defines ISIS LSP Operational Bits.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=lsp_bit.lsp_bit, is_container='container', yang_name="lsp-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsp_bit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=lsp_bit.lsp_bit, is_container='container', yang_name="lsp-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__lsp_bit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsp_bit(self):
    self.__lsp_bit = YANGDynClass(base=lsp_bit.lsp_bit, is_container='container', yang_name="lsp-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_reference_bandwidth(self):
    """
    Getter method for reference_bandwidth, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/reference_bandwidth (container)

    YANG Description: This container defines ISIS Reference Bandwidth.
    """
    return self.__reference_bandwidth
      
  def _set_reference_bandwidth(self, v, load=False):
    """
    Setter method for reference_bandwidth, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/reference_bandwidth (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reference_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reference_bandwidth() directly.

    YANG Description: This container defines ISIS Reference Bandwidth.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=reference_bandwidth.reference_bandwidth, is_container='container', yang_name="reference-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reference_bandwidth must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=reference_bandwidth.reference_bandwidth, is_container='container', yang_name="reference-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__reference_bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reference_bandwidth(self):
    self.__reference_bandwidth = YANGDynClass(base=reference_bandwidth.reference_bandwidth, is_container='container', yang_name="reference-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_nsr(self):
    """
    Getter method for nsr, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/nsr (container)

    YANG Description: This container defines ISIS Non-Stop Routing.
    """
    return self.__nsr
      
  def _set_nsr(self, v, load=False):
    """
    Setter method for nsr, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/nsr (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nsr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nsr() directly.

    YANG Description: This container defines ISIS Non-Stop Routing.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=nsr.nsr, is_container='container', yang_name="nsr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nsr must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=nsr.nsr, is_container='container', yang_name="nsr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__nsr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nsr(self):
    self.__nsr = YANGDynClass(base=nsr.nsr, is_container='container', yang_name="nsr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_graceful_restart(self):
    """
    Getter method for graceful_restart, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/graceful_restart (container)

    YANG Description: This container defines ISIS Graceful Restart.
    """
    return self.__graceful_restart
      
  def _set_graceful_restart(self, v, load=False):
    """
    Setter method for graceful_restart, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/graceful_restart (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_graceful_restart is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_graceful_restart() directly.

    YANG Description: This container defines ISIS Graceful Restart.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=graceful_restart.graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """graceful_restart must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=graceful_restart.graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__graceful_restart = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_graceful_restart(self):
    self.__graceful_restart = YANGDynClass(base=graceful_restart.graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_timers(self):
    """
    Getter method for timers, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/timers (container)

    YANG Description: This container defines ISIS timers.
    """
    return self.__timers
      
  def _set_timers(self, v, load=False):
    """
    Setter method for timers, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/timers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timers() directly.

    YANG Description: This container defines ISIS timers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=timers.timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=timers.timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__timers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timers(self):
    self.__timers = YANGDynClass(base=timers.timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_transport(self):
    """
    Getter method for transport, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/transport (container)

    YANG Description: This container defines ISIS transport.
    """
    return self.__transport
      
  def _set_transport(self, v, load=False):
    """
    Setter method for transport, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/transport (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transport is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transport() directly.

    YANG Description: This container defines ISIS transport.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=transport.transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transport must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=transport.transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__transport = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transport(self):
    self.__transport = YANGDynClass(base=transport.transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_mpls(self):
    """
    Getter method for mpls, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/mpls (container)

    YANG Description: Configuration and operational state relating to MPLS-related
features in IS-IS
    """
    return self.__mpls
      
  def _set_mpls(self, v, load=False):
    """
    Setter method for mpls, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/mpls (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mpls is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mpls() directly.

    YANG Description: Configuration and operational state relating to MPLS-related
features in IS-IS
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=mpls.mpls, is_container='container', yang_name="mpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mpls must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=mpls.mpls, is_container='container', yang_name="mpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__mpls = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mpls(self):
    self.__mpls = YANGDynClass(base=mpls.mpls, is_container='container', yang_name="mpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_igp_shortcuts(self):
    """
    Getter method for igp_shortcuts, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/igp_shortcuts (container)

    YANG Description: This container defines IGP shortcuts configuration and state
information.
    """
    return self.__igp_shortcuts
      
  def _set_igp_shortcuts(self, v, load=False):
    """
    Setter method for igp_shortcuts, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/igp_shortcuts (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_igp_shortcuts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_igp_shortcuts() directly.

    YANG Description: This container defines IGP shortcuts configuration and state
information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=igp_shortcuts.igp_shortcuts, is_container='container', yang_name="igp-shortcuts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """igp_shortcuts must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=igp_shortcuts.igp_shortcuts, is_container='container', yang_name="igp-shortcuts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__igp_shortcuts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_igp_shortcuts(self):
    self.__igp_shortcuts = YANGDynClass(base=igp_shortcuts.igp_shortcuts, is_container='container', yang_name="igp-shortcuts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_afi_safi(self):
    """
    Getter method for afi_safi, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/afi_safi (container)

    YANG Description: This container defines address-family specific configuration
and state information.
    """
    return self.__afi_safi
      
  def _set_afi_safi(self, v, load=False):
    """
    Setter method for afi_safi, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/afi_safi (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_afi_safi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_afi_safi() directly.

    YANG Description: This container defines address-family specific configuration
and state information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=afi_safi.afi_safi, is_container='container', yang_name="afi-safi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """afi_safi must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=afi_safi.afi_safi, is_container='container', yang_name="afi-safi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__afi_safi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_afi_safi(self):
    self.__afi_safi = YANGDynClass(base=afi_safi.afi_safi, is_container='container', yang_name="afi-safi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_segment_routing(self):
    """
    Getter method for segment_routing, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/segment_routing (container)

    YANG Description: Configuration and operational state relating to segment routing.
    """
    return self.__segment_routing
      
  def _set_segment_routing(self, v, load=False):
    """
    Setter method for segment_routing, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/segment_routing (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_segment_routing is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_segment_routing() directly.

    YANG Description: Configuration and operational state relating to segment routing.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=segment_routing.segment_routing, is_container='container', yang_name="segment-routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """segment_routing must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=segment_routing.segment_routing, is_container='container', yang_name="segment-routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__segment_routing = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_segment_routing(self):
    self.__segment_routing = YANGDynClass(base=segment_routing.segment_routing, is_container='container', yang_name="segment-routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)


  def _get_inter_level_propagation_policies(self):
    """
    Getter method for inter_level_propagation_policies, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/inter_level_propagation_policies (container)

    YANG Description: Policies to propagate prefixes between IS-IS levels.
    """
    return self.__inter_level_propagation_policies
      
  def _set_inter_level_propagation_policies(self, v, load=False):
    """
    Setter method for inter_level_propagation_policies, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/inter_level_propagation_policies (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inter_level_propagation_policies is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inter_level_propagation_policies() directly.

    YANG Description: Policies to propagate prefixes between IS-IS levels.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=inter_level_propagation_policies.inter_level_propagation_policies, is_container='container', yang_name="inter-level-propagation-policies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inter_level_propagation_policies must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=inter_level_propagation_policies.inter_level_propagation_policies, is_container='container', yang_name="inter-level-propagation-policies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__inter_level_propagation_policies = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inter_level_propagation_policies(self):
    self.__inter_level_propagation_policies = YANGDynClass(base=inter_level_propagation_policies.inter_level_propagation_policies, is_container='container', yang_name="inter-level-propagation-policies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  lsp_bit = __builtin__.property(_get_lsp_bit, _set_lsp_bit)
  reference_bandwidth = __builtin__.property(_get_reference_bandwidth, _set_reference_bandwidth)
  nsr = __builtin__.property(_get_nsr, _set_nsr)
  graceful_restart = __builtin__.property(_get_graceful_restart, _set_graceful_restart)
  timers = __builtin__.property(_get_timers, _set_timers)
  transport = __builtin__.property(_get_transport, _set_transport)
  mpls = __builtin__.property(_get_mpls, _set_mpls)
  igp_shortcuts = __builtin__.property(_get_igp_shortcuts, _set_igp_shortcuts)
  afi_safi = __builtin__.property(_get_afi_safi, _set_afi_safi)
  segment_routing = __builtin__.property(_get_segment_routing, _set_segment_routing)
  inter_level_propagation_policies = __builtin__.property(_get_inter_level_propagation_policies, _set_inter_level_propagation_policies)


  _pyangbind_elements = {'config': config, 'state': state, 'lsp_bit': lsp_bit, 'reference_bandwidth': reference_bandwidth, 'nsr': nsr, 'graceful_restart': graceful_restart, 'timers': timers, 'transport': transport, 'mpls': mpls, 'igp_shortcuts': igp_shortcuts, 'afi_safi': afi_safi, 'segment_routing': segment_routing, 'inter_level_propagation_policies': inter_level_propagation_policies, }


