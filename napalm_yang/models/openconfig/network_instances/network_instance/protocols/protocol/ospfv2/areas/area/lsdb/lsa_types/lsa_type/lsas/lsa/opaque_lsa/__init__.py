
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import state
import traffic_engineering
import grace_lsa
import router_information
import extended_prefix
import extended_link
import unknown_tlv
class opaque_lsa(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance - based on the path /network-instances/network-instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa-types/lsa-type/lsas/lsa/opaque-lsa. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Contents of the opaque LSA
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__state','__traffic_engineering','__grace_lsa','__router_information','__extended_prefix','__extended_link','__unknown_tlv',)

  _yang_name = 'opaque-lsa'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__grace_lsa = YANGDynClass(base=grace_lsa.grace_lsa, is_container='container', yang_name="grace-lsa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    self.__extended_prefix = YANGDynClass(base=extended_prefix.extended_prefix, is_container='container', yang_name="extended-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    self.__extended_link = YANGDynClass(base=extended_link.extended_link, is_container='container', yang_name="extended-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    self.__traffic_engineering = YANGDynClass(base=traffic_engineering.traffic_engineering, is_container='container', yang_name="traffic-engineering", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    self.__router_information = YANGDynClass(base=router_information.router_information, is_container='container', yang_name="router-information", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    self.__unknown_tlv = YANGDynClass(base=unknown_tlv.unknown_tlv, is_container='container', yang_name="unknown-tlv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'network-instances', u'network-instance', u'protocols', u'protocol', u'ospfv2', u'areas', u'area', u'lsdb', u'lsa-types', u'lsa-type', u'lsas', u'lsa', u'opaque-lsa']

  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/state (container)

    YANG Description: State parameters for the opaque LSA
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State parameters for the opaque LSA
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)


  def _get_traffic_engineering(self):
    """
    Getter method for traffic_engineering, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/traffic_engineering (container)

    YANG Description: Contents of the Traffic Engineering Opaque LSA
    """
    return self.__traffic_engineering
      
  def _set_traffic_engineering(self, v, load=False):
    """
    Setter method for traffic_engineering, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/traffic_engineering (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_traffic_engineering is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_traffic_engineering() directly.

    YANG Description: Contents of the Traffic Engineering Opaque LSA
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=traffic_engineering.traffic_engineering, is_container='container', yang_name="traffic-engineering", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """traffic_engineering must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=traffic_engineering.traffic_engineering, is_container='container', yang_name="traffic-engineering", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__traffic_engineering = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_traffic_engineering(self):
    self.__traffic_engineering = YANGDynClass(base=traffic_engineering.traffic_engineering, is_container='container', yang_name="traffic-engineering", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)


  def _get_grace_lsa(self):
    """
    Getter method for grace_lsa, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/grace_lsa (container)

    YANG Description: The Grace LSA is utilised when a remote system is undergoing
graceful restart
    """
    return self.__grace_lsa
      
  def _set_grace_lsa(self, v, load=False):
    """
    Setter method for grace_lsa, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/grace_lsa (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_grace_lsa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_grace_lsa() directly.

    YANG Description: The Grace LSA is utilised when a remote system is undergoing
graceful restart
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=grace_lsa.grace_lsa, is_container='container', yang_name="grace-lsa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """grace_lsa must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=grace_lsa.grace_lsa, is_container='container', yang_name="grace-lsa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__grace_lsa = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_grace_lsa(self):
    self.__grace_lsa = YANGDynClass(base=grace_lsa.grace_lsa, is_container='container', yang_name="grace-lsa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)


  def _get_router_information(self):
    """
    Getter method for router_information, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/router_information (container)

    YANG Description: The router information LSA is utilised to advertise capabilities
of a system to other systems who receive the LSA
    """
    return self.__router_information
      
  def _set_router_information(self, v, load=False):
    """
    Setter method for router_information, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/router_information (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_information is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_information() directly.

    YANG Description: The router information LSA is utilised to advertise capabilities
of a system to other systems who receive the LSA
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=router_information.router_information, is_container='container', yang_name="router-information", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_information must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=router_information.router_information, is_container='container', yang_name="router-information", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__router_information = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_information(self):
    self.__router_information = YANGDynClass(base=router_information.router_information, is_container='container', yang_name="router-information", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)


  def _get_extended_prefix(self):
    """
    Getter method for extended_prefix, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/extended_prefix (container)

    YANG Description: An OSPFv2 Extended Prefix Opaque LSA, used to encapsulate
TLV attributes associated with a prefix advertised in OSPF.
    """
    return self.__extended_prefix
      
  def _set_extended_prefix(self, v, load=False):
    """
    Setter method for extended_prefix, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/extended_prefix (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_extended_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_extended_prefix() directly.

    YANG Description: An OSPFv2 Extended Prefix Opaque LSA, used to encapsulate
TLV attributes associated with a prefix advertised in OSPF.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=extended_prefix.extended_prefix, is_container='container', yang_name="extended-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """extended_prefix must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=extended_prefix.extended_prefix, is_container='container', yang_name="extended-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__extended_prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_extended_prefix(self):
    self.__extended_prefix = YANGDynClass(base=extended_prefix.extended_prefix, is_container='container', yang_name="extended-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)


  def _get_extended_link(self):
    """
    Getter method for extended_link, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/extended_link (container)

    YANG Description: The OSPFv2 Extended Link Opaque LSA, used to encapsulate TLV
attributes associated with a link advertised in OSPF.
    """
    return self.__extended_link
      
  def _set_extended_link(self, v, load=False):
    """
    Setter method for extended_link, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/extended_link (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_extended_link is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_extended_link() directly.

    YANG Description: The OSPFv2 Extended Link Opaque LSA, used to encapsulate TLV
attributes associated with a link advertised in OSPF.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=extended_link.extended_link, is_container='container', yang_name="extended-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """extended_link must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=extended_link.extended_link, is_container='container', yang_name="extended-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__extended_link = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_extended_link(self):
    self.__extended_link = YANGDynClass(base=extended_link.extended_link, is_container='container', yang_name="extended-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)


  def _get_unknown_tlv(self):
    """
    Getter method for unknown_tlv, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/unknown_tlv (container)

    YANG Description: An unknown TLV within the context. Unknown TLVs are
defined to be the set of TLVs that are not modelled
within the OpenConfig model, or are unknown to the
local system such that it cannot decode their value.
    """
    return self.__unknown_tlv
      
  def _set_unknown_tlv(self, v, load=False):
    """
    Setter method for unknown_tlv, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/unknown_tlv (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unknown_tlv is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unknown_tlv() directly.

    YANG Description: An unknown TLV within the context. Unknown TLVs are
defined to be the set of TLVs that are not modelled
within the OpenConfig model, or are unknown to the
local system such that it cannot decode their value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unknown_tlv.unknown_tlv, is_container='container', yang_name="unknown-tlv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unknown_tlv must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=unknown_tlv.unknown_tlv, is_container='container', yang_name="unknown-tlv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__unknown_tlv = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unknown_tlv(self):
    self.__unknown_tlv = YANGDynClass(base=unknown_tlv.unknown_tlv, is_container='container', yang_name="unknown-tlv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)

  state = __builtin__.property(_get_state)
  traffic_engineering = __builtin__.property(_get_traffic_engineering)
  grace_lsa = __builtin__.property(_get_grace_lsa)
  router_information = __builtin__.property(_get_router_information)
  extended_prefix = __builtin__.property(_get_extended_prefix)
  extended_link = __builtin__.property(_get_extended_link)
  unknown_tlv = __builtin__.property(_get_unknown_tlv)


  _pyangbind_elements = {'state': state, 'traffic_engineering': traffic_engineering, 'grace_lsa': grace_lsa, 'router_information': router_information, 'extended_prefix': extended_prefix, 'extended_link': extended_link, 'unknown_tlv': unknown_tlv, }


import state
import traffic_engineering
import grace_lsa
import router_information
import extended_prefix
import extended_link
import unknown_tlv
class opaque_lsa(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance-l2 - based on the path /network-instances/network-instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa-types/lsa-type/lsas/lsa/opaque-lsa. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Contents of the opaque LSA
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__state','__traffic_engineering','__grace_lsa','__router_information','__extended_prefix','__extended_link','__unknown_tlv',)

  _yang_name = 'opaque-lsa'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__grace_lsa = YANGDynClass(base=grace_lsa.grace_lsa, is_container='container', yang_name="grace-lsa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    self.__extended_prefix = YANGDynClass(base=extended_prefix.extended_prefix, is_container='container', yang_name="extended-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    self.__extended_link = YANGDynClass(base=extended_link.extended_link, is_container='container', yang_name="extended-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    self.__traffic_engineering = YANGDynClass(base=traffic_engineering.traffic_engineering, is_container='container', yang_name="traffic-engineering", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    self.__router_information = YANGDynClass(base=router_information.router_information, is_container='container', yang_name="router-information", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    self.__unknown_tlv = YANGDynClass(base=unknown_tlv.unknown_tlv, is_container='container', yang_name="unknown-tlv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'network-instances', u'network-instance', u'protocols', u'protocol', u'ospfv2', u'areas', u'area', u'lsdb', u'lsa-types', u'lsa-type', u'lsas', u'lsa', u'opaque-lsa']

  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/state (container)

    YANG Description: State parameters for the opaque LSA
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State parameters for the opaque LSA
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)


  def _get_traffic_engineering(self):
    """
    Getter method for traffic_engineering, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/traffic_engineering (container)

    YANG Description: Contents of the Traffic Engineering Opaque LSA
    """
    return self.__traffic_engineering
      
  def _set_traffic_engineering(self, v, load=False):
    """
    Setter method for traffic_engineering, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/traffic_engineering (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_traffic_engineering is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_traffic_engineering() directly.

    YANG Description: Contents of the Traffic Engineering Opaque LSA
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=traffic_engineering.traffic_engineering, is_container='container', yang_name="traffic-engineering", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """traffic_engineering must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=traffic_engineering.traffic_engineering, is_container='container', yang_name="traffic-engineering", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__traffic_engineering = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_traffic_engineering(self):
    self.__traffic_engineering = YANGDynClass(base=traffic_engineering.traffic_engineering, is_container='container', yang_name="traffic-engineering", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)


  def _get_grace_lsa(self):
    """
    Getter method for grace_lsa, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/grace_lsa (container)

    YANG Description: The Grace LSA is utilised when a remote system is undergoing
graceful restart
    """
    return self.__grace_lsa
      
  def _set_grace_lsa(self, v, load=False):
    """
    Setter method for grace_lsa, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/grace_lsa (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_grace_lsa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_grace_lsa() directly.

    YANG Description: The Grace LSA is utilised when a remote system is undergoing
graceful restart
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=grace_lsa.grace_lsa, is_container='container', yang_name="grace-lsa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """grace_lsa must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=grace_lsa.grace_lsa, is_container='container', yang_name="grace-lsa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__grace_lsa = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_grace_lsa(self):
    self.__grace_lsa = YANGDynClass(base=grace_lsa.grace_lsa, is_container='container', yang_name="grace-lsa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)


  def _get_router_information(self):
    """
    Getter method for router_information, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/router_information (container)

    YANG Description: The router information LSA is utilised to advertise capabilities
of a system to other systems who receive the LSA
    """
    return self.__router_information
      
  def _set_router_information(self, v, load=False):
    """
    Setter method for router_information, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/router_information (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_information is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_information() directly.

    YANG Description: The router information LSA is utilised to advertise capabilities
of a system to other systems who receive the LSA
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=router_information.router_information, is_container='container', yang_name="router-information", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_information must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=router_information.router_information, is_container='container', yang_name="router-information", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__router_information = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_information(self):
    self.__router_information = YANGDynClass(base=router_information.router_information, is_container='container', yang_name="router-information", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)


  def _get_extended_prefix(self):
    """
    Getter method for extended_prefix, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/extended_prefix (container)

    YANG Description: An OSPFv2 Extended Prefix Opaque LSA, used to encapsulate
TLV attributes associated with a prefix advertised in OSPF.
    """
    return self.__extended_prefix
      
  def _set_extended_prefix(self, v, load=False):
    """
    Setter method for extended_prefix, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/extended_prefix (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_extended_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_extended_prefix() directly.

    YANG Description: An OSPFv2 Extended Prefix Opaque LSA, used to encapsulate
TLV attributes associated with a prefix advertised in OSPF.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=extended_prefix.extended_prefix, is_container='container', yang_name="extended-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """extended_prefix must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=extended_prefix.extended_prefix, is_container='container', yang_name="extended-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__extended_prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_extended_prefix(self):
    self.__extended_prefix = YANGDynClass(base=extended_prefix.extended_prefix, is_container='container', yang_name="extended-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)


  def _get_extended_link(self):
    """
    Getter method for extended_link, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/extended_link (container)

    YANG Description: The OSPFv2 Extended Link Opaque LSA, used to encapsulate TLV
attributes associated with a link advertised in OSPF.
    """
    return self.__extended_link
      
  def _set_extended_link(self, v, load=False):
    """
    Setter method for extended_link, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/extended_link (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_extended_link is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_extended_link() directly.

    YANG Description: The OSPFv2 Extended Link Opaque LSA, used to encapsulate TLV
attributes associated with a link advertised in OSPF.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=extended_link.extended_link, is_container='container', yang_name="extended-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """extended_link must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=extended_link.extended_link, is_container='container', yang_name="extended-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__extended_link = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_extended_link(self):
    self.__extended_link = YANGDynClass(base=extended_link.extended_link, is_container='container', yang_name="extended-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)


  def _get_unknown_tlv(self):
    """
    Getter method for unknown_tlv, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/unknown_tlv (container)

    YANG Description: An unknown TLV within the context. Unknown TLVs are
defined to be the set of TLVs that are not modelled
within the OpenConfig model, or are unknown to the
local system such that it cannot decode their value.
    """
    return self.__unknown_tlv
      
  def _set_unknown_tlv(self, v, load=False):
    """
    Setter method for unknown_tlv, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/unknown_tlv (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unknown_tlv is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unknown_tlv() directly.

    YANG Description: An unknown TLV within the context. Unknown TLVs are
defined to be the set of TLVs that are not modelled
within the OpenConfig model, or are unknown to the
local system such that it cannot decode their value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unknown_tlv.unknown_tlv, is_container='container', yang_name="unknown-tlv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unknown_tlv must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=unknown_tlv.unknown_tlv, is_container='container', yang_name="unknown-tlv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__unknown_tlv = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unknown_tlv(self):
    self.__unknown_tlv = YANGDynClass(base=unknown_tlv.unknown_tlv, is_container='container', yang_name="unknown-tlv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)

  state = __builtin__.property(_get_state)
  traffic_engineering = __builtin__.property(_get_traffic_engineering)
  grace_lsa = __builtin__.property(_get_grace_lsa)
  router_information = __builtin__.property(_get_router_information)
  extended_prefix = __builtin__.property(_get_extended_prefix)
  extended_link = __builtin__.property(_get_extended_link)
  unknown_tlv = __builtin__.property(_get_unknown_tlv)


  _pyangbind_elements = {'state': state, 'traffic_engineering': traffic_engineering, 'grace_lsa': grace_lsa, 'router_information': router_information, 'extended_prefix': extended_prefix, 'extended_link': extended_link, 'unknown_tlv': unknown_tlv, }


